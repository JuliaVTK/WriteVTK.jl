var documenterSearchIndex = {"docs":
[{"location":"grids/datasets/#Writing-datasets","page":"Writing datasets","title":"Writing datasets","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"In VTK files, datasets represent scalar, vector or tensor quantities that one may want to visualise. These quantities are generally attached to either grid points or cells.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The simplest syntax for writing datasets to a file is as follows:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\n\nvtk_grid(\"fields\", x, y, z) do vtk\n    vtk[\"Temperature\"] = rand(Nx, Ny, Nz)              # scalar field attached to points\n    vtk[\"Pressure\"] = rand(Nx - 1, Ny - 1, Nz - 1)     # scalar field attached to cells\n    vtk[\"Velocity\"] = rand(3, Nx, Ny, Nz)              # vector field attached to points\n    vtk[\"VelocityGradients\"] = rand(3, 3, Nx, Ny, Nz)  # 3×3 tensor field attached to points\n    vtk[\"date\"] = \"31/10/2021\"                         # metadata (\"field data\" in VTK)\n    vtk[\"time\"] = 0.42                                 # metadata (\"field data\" in VTK)\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"In the above example, WriteVTK automatically decides whether data is to be attached to grid points or to grid cells depending on the dimensions of the input. In particular, note that the Pressure field is attached to cells instead of points, since it has dimensions (N_x - 1)  (N_y - 1)  (N_z - 1), which is the number of cells in structured files (see Cells in structured formats). For more control, see Dataset types below.","category":"page"},{"location":"grids/datasets/#Passing-tuples-of-arrays","page":"Writing datasets","title":"Passing tuples of arrays","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"Note that, in the example above, the Velocity vector field is passed as a single 3  N_x  N_y  N_z array, which is the layout ultimately used in VTK formats. In some applications, one may instead prefer to work with vector fields as a collection of separate scalar fields, or similarly as an array of dimensions N_x  N_y  N_z  3.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"To avoid unnecessary allocations in transposing the data to 3  N_x  N_y  N_z format, WriteVTK also allows passing vector and tensor fields as tuples of arrays. For example:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\nvx, vy, vz = rand(Nx, Ny, Nz), rand(Nx, Ny, Nz), rand(Nx, Ny, Nz)  # vector as separate fields\nω = rand(Nx, Ny, Nz, 3)\n∇v = rand(Nx, Ny, Nz, 3, 3)\n\nvtk_grid(\"fields_tuples\", x, y, z) do vtk\n    # Pass vectors as tuples of scalars\n    vtk[\"Velocity\"] = (vx, vy, vz)\n    vtk[\"Vorticity\"] = @views (ω[:, :, :, 1], ω[:, :, :, 2], ω[:, :, :, 3])\n\n    # Similarly for tensors\n    vtk[\"VelocityGradients\"] = @views (\n        ∇v[:, :, :, 1, 1], ∇v[:, :, :, 2, 1], ∇v[:, :, :, 3, 1],\n        ∇v[:, :, :, 1, 2], ∇v[:, :, :, 2, 2], ∇v[:, :, :, 3, 2],\n        ∇v[:, :, :, 1, 3], ∇v[:, :, :, 2, 3], ∇v[:, :, :, 3, 3],\n    )\nend","category":"page"},{"location":"grids/datasets/#Passing-arrays-of-static-arrays","page":"Writing datasets","title":"Passing arrays of static arrays","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"Alternatively, a common use case is to store vector fields as arrays of static arrays, using the StaticArrays package. This use case is naturally supported by WriteVTK:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"using StaticArrays\n\nx, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\nv = rand(SVector{3, Float64}, Nx, Ny, Nz)\n∇v = rand(SMatrix{3, 3, Float32, 9}, Nx, Ny, Nz)\n\nvtk_grid(\"fields_sarray\", x, y, z) do vtk\n    vtk[\"Velocity\"] = v\n    vtk[\"VelocityGradients\"] = ∇v\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"One may also specify grid coordinates using arrays of static arrays:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"using StaticArrays\n\nNx, Ny, Nz = 5, 6, 10\nxs = [SVector(sqrt(i) + 2j + 3k, 2i - j + k, -i + 3j - k)\n      for i = 1:Nx, j = 1:Ny, k = 1:Nz]\n\nvtk_grid(\"coords_sarray\", xs) do vtk\n    # add datasets here...\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"note: (Lack of) dependencies\nNote that the WriteVTK package does not directly depend on StaticArrays, as there is no StaticArrays-specific implementation allowing for the functionality described in this section. Instead, the implementation is quite generic, and the above may also work with array types that behave similarly to StaticArrays.","category":"page"},{"location":"grids/datasets/#Dataset-types","page":"Writing datasets","title":"Dataset types","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The syntax exposed above is high-level, in the sense that WriteVTK automatically decides on the type of dataset depending on the dimensions of the input data.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The VTK format defines three different kinds of dataset:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"VTKPointData for data attached to grid points,\nVTKCellData for data attached to grid cells,\nVTKFieldData for everything else. This may be used to store lightweight metadata, such as time information or strings.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"For more control, one can explicitly pass an instance of VTKPointData, VTKCellData and VTKFieldData when adding a dataset to a VTK file.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"For example:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\n\nvtk_grid(\"fields_explicit\", x, y, z) do vtk\n    vtk[\"Temperature\", VTKPointData()] = rand(Nx, Ny, Nz)\n    vtk[\"Pressure\", VTKCellData()] = rand(Nx - 1, Ny - 1, Nz - 1)\n    vtk[\"Velocity\", VTKPointData()] = rand(3, Nx, Ny, Nz)\n    vtk[\"VelocityGradients\", VTKPointData()] = rand(3, 3, Nx, Ny, Nz)\n    vtk[\"date\", VTKFieldData()] = \"31/10/2021\"\n    vtk[\"time\", VTKFieldData()] = 0.42\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"Attributes can also be added to dataset types.  In the following example this is used to set direction dependent degrees for VTKCellTypes.VTK_LAGRANGE_QUADRILATERAL cells.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"cells = [\n  MeshCell(VTKCellTypes.VTK_LAGRANGE_QUADRILATERAL, [\n    1, 3, 12, 10, 2, 6, 9, 11, 4, 7, 5, 8\n  ]),\n]\nx = [0, 0.5, 1, 0, 0.5, 1, 0, 0.5, 1, 0, 0.5, 1]\ny = [0, 0, 0, 1/3, 1/3, 1/3, 2/3, 2/3, 2/3, 1, 1, 1]\nvtk_grid(\"higherorderdegrees\", x, y, cells; part = 1, nparts = 1) do pvtk\n  pvtk[\"HigherOrderDegrees\", VTKCellData()] = [2;3;12]\n  pvtk[VTKCellData()] = Dict(\"HigherOrderDegrees\"=>\"HigherOrderDegrees\")\nend","category":"page"},{"location":"metadata/multiblock/#Multiblock-files","page":"Multiblock files","title":"Multiblock files","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Multiblock files (.vtm) are XML VTK files that can point to multiple other VTK files. They can be useful when working with complex geometries that are composed of multiple sub-domains.","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"To generate a multiblock file, it must first be initialised using vtk_multiblock:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"vtm = vtk_multiblock(\"my_vtm_file\")","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Then, each sub-grid can be generated with vtk_grid using vtm as the first argument:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# First block.\nlet vtk = vtk_grid(vtm, x1, y1, z1)\n    vtk[\"Pressure\"] = p1\nend\n\n# Second block.\nlet vtk = vtk_grid(vtm, x2, y2, z2)\n    vtk[\"Pressure\"] = p2\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Additional blocks can also be added to the multiblock file with multiblock_add_block, which can contain any of the VTK files that WriteVTK supports:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# Create a block named \"my_multiblock\" and add it to `vtm`.\nblock = multiblock_add_block(vtm, \"my_multiblock\")\n\n# Add a VTK file to `block`.\nlet vtk = vtk_grid(block, \"another_file\", x3, y3, z3)\n    vtk[\"Pressure\"] = p3\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Blocks can be nested arbitrarily:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# Add more blocks.\nanother_block = multiblock_add_block(block, \"my_multiblock-block\")\nyet_another_block = multiblock_add_block(another_block, \"my_multiblock-block-block\")","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"And more VTK files may be added to the sub-blocks:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"vtk = vtk_grid(yet_another_block, \"my_deeply_nested_file\", x4, y4, z4)","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Finally, only the multiblock file needs to be saved explicitly:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"outfiles = vtk_save(vtm)","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"WriteVTK will write out a multiblock VTK file that looks like something like this (in addition to all the VTK files contained in the multiblock file):","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\" byte_order=\"LittleEndian\">\n  <vtkMultiBlockDataSet>\n    <DataSet index=\"0\" file=\"my_vtm_file_1.vti\"/>\n    <DataSet index=\"1\" file=\"my_vtm_file_2.vti\"/>\n    <Block index=\"2\" name=\"my_multiblock\">\n      <DataSet index=\"0\" file=\"another_file.vti\" name=\"another_file\"/>\n      <Block index=\"1\" name=\"my_multiblock-block\">\n        <Block index=\"0\" name=\"my_multiblock-block-block\">\n          <DataSet index=\"0\" file=\"my_deeply_nested_file.vti\" name=\"my_deeply_nested_file\"/>\n        </Block>\n      </Block>\n    </Block>\n  </vtkMultiBlockDataSet>\n</VTKFile>","category":"page"},{"location":"metadata/multiblock/#Working-example","page":"Multiblock files","title":"Working example","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"The full above example may also be written using the do-block syntax as follows:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"x1, y1, z1 = 0:10, 1:6, 2:0.1:3\nx2, y2, z2 = 10:14, 1:0.5:4, 2:0.1:3\nx3, y3, z3 = 14:0.1:15, 3:0.5:4, 1:0.1:1.5\nx4, y4, z4 = [0, 0.3, 1.2], range(0, 1, length = 3), [1, 1.3, 2]\n\nsaved_files = vtk_multiblock(\"full_domain\") do vtm\n    # First block.\n    # By default, since the name of the file is not given, the file \"full_domain_1.vti\" will be saved.\n    vtk_grid(vtm, x1, y1, z1) do vtk\n        vtk[\"Pressure\"] = rand(length(x1), length(y1), length(z1))\n    end\n\n    # Second block.\n    # Note that we can override the default filename.\n    # In this case, the filename will be \"block_2.vti\" instead of \"full_domain_2.vti\".\n    vtk_grid(vtm, \"block_2\", x2, y2, z2) do vtk\n        vtk[\"Pressure\"] = rand(length(x2), length(y2), length(z2))\n    end\n\n    # Create a block named \"my_multiblock\" and add it to `vtm`.\n    block = multiblock_add_block(vtm, \"my_multiblock\")\n\n    # Add a VTK file to `block`.\n    vtk_grid(block, \"another_file\", x3, y3, z3) do vtk\n        vtk[\"Pressure\"] = rand(length(x3), length(y3), length(z3))\n    end\n\n    # Add nested blocks.\n    another_block = multiblock_add_block(block, \"my_multiblock-block\")\n    yet_another_block = multiblock_add_block(another_block, \"my_multiblock-block-block\")\n\n    vtk_grid(yet_another_block, \"my_deeply_nested_file\", x4, y4, z4) do vtk\n        vtk[\"Pressure\"] = rand(length(x4), length(y4), length(z4))\n    end\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"This will generate the following files:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"julia> saved_files\n5-element Vector{String}:\n \"full_domain.vtm\"\n \"full_domain_1.vti\"\n \"block_2.vti\"\n \"another_file.vti\"\n \"my_deeply_nested_file.vtr\"","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"By opening full_domain.vtm in ParaView, one can get the following picture:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"(Image: Visualisation of multiblock file.)","category":"page"},{"location":"metadata/multiblock/#Acknowledgements","page":"Multiblock files","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Thanks to Daniel Ingraham for the implementation of recursive multiblock functionality.","category":"page"},{"location":"external/VTKBase/#VTKBase.jl","page":"VTKBase.jl","title":"VTKBase.jl","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"The VTKBase.jl package contains common definitions used in the WriteVTK.jl and ReadVTK.jl packages.","category":"page"},{"location":"external/VTKBase/#VTK-dataset-types","page":"VTKBase.jl","title":"VTK dataset types","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"AbstractVTKDataset\nStructuredVTKDataset\nVTKImageData\nVTKRectilinearGrid\nVTKStructuredGrid\nUnstructuredVTKDataset\nVTKPolyData\nVTKUnstructuredGrid","category":"page"},{"location":"external/VTKBase/#VTKBase.AbstractVTKDataset","page":"VTKBase.jl","title":"VTKBase.AbstractVTKDataset","text":"AbstractVTKDataset\n\nAbstract type representing any structured or unstructured VTK dataset.\n\nThe dataset classification is described in the VTK file format specification, page 12.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.StructuredVTKDataset","page":"VTKBase.jl","title":"VTKBase.StructuredVTKDataset","text":"StructuredVTKDataset <: AbstractVTKDataset\n\nAbstract type representing a structured VTK dataset.\n\nSubtypes are VTKImageData, VTKRectilinearGrid and VTKStructuredGrid.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKImageData","page":"VTKBase.jl","title":"VTKBase.VTKImageData","text":"VTKImageData <: StructuredVTKDataset\n\nRepresents the VTK image data format (.vti extension).\n\nThis corresponds to rectangular grids with uniform spacing in all directions.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKRectilinearGrid","page":"VTKBase.jl","title":"VTKBase.VTKRectilinearGrid","text":"VTKRectilinearGrid <: StructuredVTKDataset\n\nRepresents the VTK rectilinear grid format (.vtr extension).\n\nThis corresponds to rectangular grids with non-uniform spacing.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKStructuredGrid","page":"VTKBase.jl","title":"VTKBase.VTKStructuredGrid","text":"VTKStructuredGrid <: StructuredVTKDataset\n\nRepresents the VTK structured grid format (.vts extension).\n\nThis corresponds to curvilinear grids, the most general kind of structured grid.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.UnstructuredVTKDataset","page":"VTKBase.jl","title":"VTKBase.UnstructuredVTKDataset","text":"UnstructuredVTKDataset <: AbstractVTKDataset\n\nAbstract type representing an unstructured VTK dataset.\n\nSubtypes are VTKPolyData and VTKUnstructuredGrid.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKPolyData","page":"VTKBase.jl","title":"VTKBase.VTKPolyData","text":"VTKPolyData <: UnstructuredVTKDataset\n\nRepresents the VTK polydata format (.vtp extension).\n\nThese are unstructured datasets that accept a limited set of cells types, defined in the PolyData module.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKUnstructuredGrid","page":"VTKBase.jl","title":"VTKBase.VTKUnstructuredGrid","text":"VTKUnstructuredGrid <: UnstructuredVTKDataset\n\nRepresents the VTK unstructured format (.vtu extension).\n\nThis is the most general kind of unstructured grid, which accepts all cell types defined in the VTKCellTypes module.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#Field-data-types","page":"VTKBase.jl","title":"Field data types","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"In VTK, data can either be attached to the geometry (point and cell data), or not (field data).","category":"page"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"VTKBase.AbstractFieldData\nVTKPointData\nVTKCellData\nVTKFieldData","category":"page"},{"location":"external/VTKBase/#VTKBase.AbstractFieldData","page":"VTKBase.jl","title":"VTKBase.AbstractFieldData","text":"AbstractFieldData\n\nAbstract type representing any kind of dataset.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKPointData","page":"VTKBase.jl","title":"VTKBase.VTKPointData","text":"VTKPointData <: AbstractFieldData\n\nRepresents data that is to be attached to grid points.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKCellData","page":"VTKBase.jl","title":"VTKBase.VTKCellData","text":"VTKCellData <: AbstractFieldData\n\nRepresents data that is to be attached to grid cells.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.VTKFieldData","page":"VTKBase.jl","title":"VTKBase.VTKFieldData","text":"VTKFieldData <: AbstractFieldData\n\nRepresents data that is not attached to the grid geometry.\n\nThis is typically used for lightweight metadata, such as timestep information or strings.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#Cells-in-unstructured-grids","page":"VTKBase.jl","title":"Cells in unstructured grids","text":"","category":"section"},{"location":"external/VTKBase/#General-unstructured-datasets","page":"VTKBase.jl","title":"General unstructured datasets","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"These are useful when working with general unstructured datasets (.vtu files).","category":"page"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"VTKCellTypes\nVTKCellTypes.nodes\nVTKBase.AbstractMeshCell\nMeshCell","category":"page"},{"location":"external/VTKBase/#VTKBase.VTKCellTypes","page":"VTKBase.jl","title":"VTKBase.VTKCellTypes","text":"VTKCellTypes\n\nModule defining cell types for unstructured datasets.\n\nDefinitions are adapted from the VTK source code.\n\n\n\n\n\n","category":"module"},{"location":"external/VTKBase/#VTKBase.VTKCellTypes.nodes","page":"VTKBase.jl","title":"VTKBase.VTKCellTypes.nodes","text":"nodes(c::VTKCellTypes)\n\nReturns the number of nodes (or grid points) required by the cell type.\n\nFor instance, this returns 3 for VTK_TRIANGLE.\n\nFor cell types that can take any number of nodes, such as VTK_POLY_LINE, this returns -1.\n\n\n\n\n\n","category":"function"},{"location":"external/VTKBase/#VTKBase.AbstractMeshCell","page":"VTKBase.jl","title":"VTKBase.AbstractMeshCell","text":"AbstractMeshCell\n\nAbstract type specifying a VTK cell.\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#VTKBase.MeshCell","page":"VTKBase.jl","title":"VTKBase.MeshCell","text":"MeshCell <: AbstractMeshCell\n\nSingle cell element in unstructured or polygonal grid.\n\nIt is characterised by a cell type (for instance, VTKCellType.TRIANGLE or PolyData.Strips) and by a connectivity vector determining the points on the grid defining this cell.\n\n\n\nMeshCell(cell_type, connectivity)\n\nDefine a single cell element of an unstructured grid.\n\nThe cell_type argument characterises the type of cell (e.g. vertex, triangle, hexaedron, ...):\n\ncell types for unstructured datasets are defined in the VTKCellTypes\n\nmodule;\n\ncell types for polygonal datasets are defined in the PolyData module.\n\nThe connectivity argument is a vector or tuple containing the indices of the points passed to vtk_grid which define this cell.\n\nExample\n\nDefine a triangular cell passing by points with indices [3, 5, 42].\n\njulia> cell = MeshCell(VTKCellTypes.VTK_TRIANGLE, (3, 5, 42))\nMeshCell{VTKCellType, Tuple{Int64, Int64, Int64}}(VTKCellType(\"VTK_TRIANGLE\", 0x05, 3), (3, 5, 42))\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#Polygonal-datasets","page":"VTKBase.jl","title":"Polygonal datasets","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"These are useful when working with polygonal datasets (.vtp files).","category":"page"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"PolyData\nVTKPolyhedron","category":"page"},{"location":"external/VTKBase/#VTKBase.PolyData","page":"VTKBase.jl","title":"VTKBase.PolyData","text":"PolyData\n\nDefines cell types for polygonal datasets.\n\nThe following singleton types are defined:\n\nPolyData.Verts for vertices,\nPolyData.Lines for lines,\nPolyData.Strips for triangular strips,\nPolyData.Polys for polygons.\n\n\n\n\n\n","category":"module"},{"location":"external/VTKBase/#VTKBase.VTKPolyhedron","page":"VTKBase.jl","title":"VTKBase.VTKPolyhedron","text":"VTKPolyhedron <: AbstractMeshCell\n\nRepresents a polyhedron cell in an unstructured grid.\n\nUsing VTKPolyhedron should be preferred to using a MeshCell with a cell type VTKCellTypes.VTK_POLYHEDRON, since the latter cannot hold all the necessary information to describe a polyhedron cell.\n\n\n\nVTKPolyhedron(connectivity, faces...)\n\nConstruct polyhedron cell from connectivity vector (see MeshCell for details) and from a list of polyhedron faces.\n\nExample\n\nCreate a polyhedron with 8 points and 6 faces. This can represent a cube if the 8 points are properly positioned.\n\njulia> cell = VTKPolyhedron(\n           1:8,\n           (1, 4, 3, 2),\n           (1, 5, 8, 4),\n           (5, 6, 7, 8),\n           (6, 2, 3, 7),\n           (1, 2, 6, 5),\n           (3, 4, 8, 7),\n       )\nVTKPolyhedron{UnitRange{Int64}, NTuple{6, NTuple{4, Int64}}}(1:8, ((1, 4, 3, 2), (1, 5, 8, 4), (5, 6, 7, 8), (6, 2, 3, 7), (1, 2, 6, 5), (3, 4, 8, 7)))\n\n\n\n\n\n","category":"type"},{"location":"external/VTKBase/#Constants","page":"VTKBase.jl","title":"Constants","text":"","category":"section"},{"location":"external/VTKBase/","page":"VTKBase.jl","title":"VTKBase.jl","text":"VTKBase.VTKDataType","category":"page"},{"location":"external/VTKBase/#VTKBase.VTKDataType","page":"VTKBase.jl","title":"VTKBase.VTKDataType","text":"VTKDataType\n\nUnion of integer, float and string data types allowed by VTK.\n\n\n\n\n\n","category":"type"},{"location":"metadata/parallel/#Parallel-files","page":"Parallel files","title":"Parallel files","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The parallel file formats do not actually store any data in the file. Instead, the data is broken into pieces, each of which is stored in a serial file, and an extra header file is created containing pointers to the corresponding serial files. The header file extension is the serial extension prepended with a p. For instance, for serial vtu files, the corresponding header file extension is pvtu.","category":"page"},{"location":"metadata/parallel/#Generating-a-parallel-data-file","page":"Parallel files","title":"Generating a parallel data file","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The parallel header file and the corresponding serial files are generated by a single call to pvtk_grid. Its signature is","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"pvtk_grid(\n    filename, args...;\n    part, nparts, ismain = (part == 1), ghost_level = 0, kwargs...,\n)","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"which returns a handler representing a parallel VTK file that can be appended with cell and point data and eventually written to disk with vtk_save as usual. In an MPI job, vtk_save will cause each rank to write a serial file and just a single rank (e.g., rank 0) will write the header file.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"This signature is valid for unstructured grids. For the case of structured grids, there are small differences detailed further below.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Positional and keyword arguments in args and kwargs are passed to vtk_grid verbatim. Note that serial filenames are automatically generated from filename and from the process id part.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The following keyword arguments only apply to parallel VTK file formats.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Mandatory ones are:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"part: current (1-based) part id (typically MPI rank + 1),\nnparts: total number of parts (typically the MPI communicator size).","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Optional ones are:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"ismain: true if the current part id part is the main (the only one that will write the header file),\nghost_level: ghost level.","category":"page"},{"location":"metadata/parallel/#Parallel-structured-files","page":"Parallel files","title":"Parallel structured files","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"For structured grids, one needs to specify the portion of the grid associated to each process. This is done via the extents keyword argument, which must be an array containing the data ranges along each dimension associated to each process. For example, for a dataset of global dimensions 15124 distributed across 4 processes, this array may look like the following:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"extents = [\n    ( 1:10,  1:5, 1:4),  # process 1\n    (10:15,  1:5, 1:4),  # process 2\n    ( 1:10, 5:12, 1:4),  # process 3\n    (10:15, 5:12, 1:4),  # process 4\n]","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"In practice, in parallel applications, all processes need to have this information, and the extents argument must be the same for all processes. Also note that the length of the extents array gives the number of processes, and therefore the nparts argument is redundant and not needed for structured grids.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Finally, note that in the example above the extents for different processes overlap (for instance, the ranges 1:10 and 10:15 overlap at the index i = 10). This is a requirement of VTK, and without it the full data cannot be visualised in ParaView. For MPI applications, this typically means that ghost data need to be exchanged before writing VTK files.","category":"page"},{"location":"metadata/parallel/#Example-1:-Unstructured-files","page":"Parallel files","title":"Example 1: Unstructured files","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"This generates two serial files (typically held by two different processes) and a header file combining them:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"all_data = [\n    # Process 1\n    (\n        points = rand(3, 5),  # 5 points on process 1\n        cells = [             # 2 cells  on process 1\n            MeshCell(VTKCellTypes.VTK_TRIANGLE, [1, 4, 2]),\n            MeshCell(VTKCellTypes.VTK_QUAD, [2, 4, 3, 5]),\n        ],\n    ),\n\n    # Process 2\n    (\n        points = rand(3, 4),  # 4 points on process 2\n        cells = [             # 1 cell   on process 2\n            MeshCell(VTKCellTypes.VTK_QUAD, [1, 2, 3, 4]),\n        ]\n    ),\n]\n\nsaved_files = Vector{Vector{String}}(undef, 2)  # files saved by each \"process\"\n\nfor part = 1:2\n    data = all_data[part]\n    saved_files[part] = pvtk_grid(\n            \"simulation\", data.points, data.cells;\n            part = part, nparts = 2,\n        ) do pvtk\n        pvtk[\"Pressure\"] = sum(data.points; dims = 1)\n    end\nend","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"In this example, saved_files lists the files saved by each \"process\":","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"julia> saved_files\n2-element Vector{Vector{String}}:\n [\"simulation.pvtu\", \"simulation/simulation_1.vtu\"]\n [\"simulation/simulation_2.vtu\"]","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Note that the files containing the actual data (in this case simulation_*.vtu) are stored in a separate simulation directory.","category":"page"},{"location":"metadata/parallel/#Example-2:-Structured-files","page":"Parallel files","title":"Example 2: Structured files","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"This generates 4 serial image data files (.vti) and a header file (.pvti) combining them:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"# Global grid\nxs_global = range(0, 2; length = 15)\nys_global = range(-1, 1; length = 12)\nzs_global = range(0, 1; length = 4)\n\nextents = [\n    ( 1:10,  1:5, 1:4),  # process 1\n    (10:15,  1:5, 1:4),  # process 2\n    ( 1:10, 5:12, 1:4),  # process 3\n    (10:15, 5:12, 1:4),  # process 4\n]\n\nsaved_files = Vector{Vector{String}}(undef, 4)  # files saved by each \"process\"\n\nfor part = 1:4\n    is, js, ks = extents[part]  # local indices\n    xs, ys, zs = xs_global[is], ys_global[js], zs_global[ks]  # local grid\n    saved_files[part] = pvtk_grid(\n            \"fields\", xs, ys, zs;\n            part = part, extents = extents,\n        ) do pvtk\n        pvtk[\"Temperature\"] = [x + 2y + 3z for x ∈ xs, y ∈ ys, z ∈ zs]\n    end\nend","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"As in the previous example, saved_files lists the files saved by each \"process\":","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"julia> saved_files\n4-element Vector{Vector{String}}:\n [\"fields.pvti\", \"fields/fields_1.vti\"]\n [\"fields/fields_2.vti\"]\n [\"fields/fields_3.vti\"]\n [\"fields/fields_4.vti\"]","category":"page"},{"location":"metadata/parallel/#Acknowledgements","page":"Parallel files","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Thanks to Francesc Verdugo and Alberto F. Martin for the initial parallel file format implementation, and to Corentin Lothode for the initial work on structured grids.","category":"page"},{"location":"tools/write_array/#Visualising-Julia-arrays","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"A convenience function, vtk_write_array, is provided to quickly save Julia arrays as image data:","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"p = rand(100, 100, 100)\nvtk_write_array(\"filename\", p, \"Pressure\")","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"This may be useful for visualising the data contained in a Julia array.","category":"page"},{"location":"tools/write_array/#Writing-multiple-arrays","page":"Visualising Julia arrays","title":"Writing multiple arrays","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"Multiple arrays can be given as a tuple. For instance,","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"vtk_write_array(\"filename\", (u, v), (\"u\", \"v\"))","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"In that case, the arrays must have the same dimensions.","category":"page"},{"location":"tools/write_array/#Acknowledgements","page":"Visualising Julia arrays","title":"Acknowledgements","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"Thanks to Júlio Hoffimann for adding this functionality.","category":"page"},{"location":"grids/unstructured/#Unstructured-grid-formats","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Unstructured grids are those in which each grid point (or vertex) can be arbitrarily placed in space. Such points are generally connected to define cells of different shapes.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"In general, unstructured grids require the specification of grid points, and of the cells that define the mesh. A cell is specified by a shape (tetrahedron, triangle, ...) and by a list of grid points (the connectivity vector) that define the cell. In WriteVTK, a cell is described by a MeshCell object.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"An unstructured grid is then defined by passing a list of grid coordinates and of cells to vtk_grid, as in","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"vtk_grid(\"filename\", points, cells)","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"As detailed in the next sections, depending on the actual kind of MeshCells contained in cells, either an unstructured grid (.vtu) or a polydata grid (.vtp) file is written.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Above, points is an array with the point locations, of dimensions (dim, num_points) where dim is the spatial dimension (1, 2 or 3) and num_points the number of points. Alternatively, grid points may be specified by passing separate 1D vectors of length num_points, as in","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"vtk_grid(\"filename\", x, y, z, cells)","category":"page"},{"location":"grids/unstructured/#Defining-cells","page":"Unstructured grid formats","title":"Defining cells","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"A single cell is created as","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"cell = MeshCell(cell_type, connectivity)","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Here, cell_type defines the cell shape, while connectivity is a list of grid point indices determining the cell location. Note that the connectivity indices are one-based (as opposed to zero-based), following the convention in Julia.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"For example, the following creates a triangular cell:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"cell = MeshCell(VTKCellTypes.VTK_TRIANGLE, (1, 2, 4))","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Note that, since this is a triangle, the connectivity vector must contain three elements (corresponding to the three vertices of the triangle), and an error is thrown if that is not the case.","category":"page"},{"location":"grids/unstructured/#Unstructured-grid","page":"Unstructured grid formats","title":"Unstructured grid","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The cell types available for the unstructured grid format are those listed in the VTK specification (figures 2 and 3). For convenience, WriteVTK includes a VTKCellTypes module that contains these definitions. For instance, a triangle is associated to the cell type VTKCellTypes.VTK_TRIANGLE.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The following example creates a filename.vtu file with two cells:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"points = rand(3, 5)  # 5 points in three dimensions\ncells = [MeshCell(VTKCellTypes.VTK_TRIANGLE, [1, 4, 2]),\n         MeshCell(VTKCellTypes.VTK_QUAD,     [2, 4, 3, 5])]\n\nvtk_grid(\"filename\", points, cells) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/unstructured/#Polydata-grid","page":"Unstructured grid formats","title":"Polydata grid","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"This is a specific type of unstructured grid that is restricted to a small subset of cell types, namely vertices, lines, triangle strips and polygons. In WriteVTK, these shapes are respectively identified by the singleton types PolyData.Verts, PolyData.Lines, PolyData.Strips and PolyData.Polys (see also the PolyData module).","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Polydata cells are specified by passing one of the above types to MeshCell. For instance, the following specifies a line passing by 4 points of the grid:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"line = MeshCell(PolyData.Lines(), [3, 4, 7, 2])","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Similarly to unstructured grids, a VTK file is created by passing vectors of cells to vtk_grid. The difference is that one can pass multiple vectors (one for each cell type), and that each vector may only contain a single cell type.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Example:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"# Create lists of lines and polygons connecting different points in space\npoints = rand(3, 100)  # (x, y, z) locations\nlines = [MeshCell(PolyData.Lines(), (i, i + 1, i + 4)) for i in (3, 5, 42)]\npolys = [MeshCell(PolyData.Polys(), i:(i + 6)) for i = 1:3:20]\n\nvtk_grid(\"my_vtp_file\", points, lines, polys) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"warning: Known issue\nWhen the polygonal dataset contains multiple kinds of cells (e.g. both lines and polygons), cell data is not correctly parsed by the VTK libraries, and as a result it cannot be visualised in ParaView. The problem doesn't happen with point data. This seems to be a very old VTK issue.","category":"page"},{"location":"grids/unstructured/#Polyhedron-cells","page":"Unstructured grid formats","title":"Polyhedron cells","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"WriteVTK also supports the creation of unstructured VTK files containing polyhedron cells. The specificity of polyhedron cells is that they require the specification not only of a connectivity vector, but also of a list of faces constituting the polyhedron. To specify a polyhedron cell, instead of using the MeshCell type, one should create an instance of VTKPolyhedron.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The following simple example creates a cube as a polyhedron cell (see also test/polyhedron_cube.jl for an example with two cubes):","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"# Vertices of the cube\npoints = permutedims(Float32[\n    -1 -1 -1;\n     1 -1 -1;\n     1  1 -1;\n    -1  1 -1;\n    -1 -1  1;\n     1 -1  1;\n     1  1  1;\n    -1  1  1;\n])\n\n# Create a single polyhedron cell describing the cube\ncells = [\n    VTKPolyhedron(\n        1:8,           # connectivity vector\n        (1, 4, 3, 2),  # face 1\n        (1, 5, 8, 4),  # face 2\n        (5, 6, 7, 8),  # etc...\n        (6, 2, 3, 7),\n        (1, 2, 6, 5),\n        (3, 4, 8, 7),\n    ),\n]\n\n# Finally, create a simple VTK file\nvtk_grid(\"polyhedron_cube\", points, cells) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/#Structured-grid-formats","page":"Structured grid formats","title":"Structured grid formats","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Structured grids are those in which each grid point (or vertex) can be specified by a set of indices such as (i, j, k) in three dimensions.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In general, structured grids in WriteVTK are generated using one of the following syntaxes:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", x, y, z; kwargs...)\nvtk_grid(\"filename\", xyz; kwargs...)","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Note that, while all examples here are done in three-dimensions, things also work as expected in two dimensions (e.g. by only passing x and y coordinates to vtk_grid).","category":"page"},{"location":"grids/structured/#Rectilinear-grid","page":"Structured grid formats","title":"Rectilinear grid","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In a rectilinear grid, points are aligned with the Cartesian directions. In this case, grid points may be specified by bmx_ijk = (x_i y_j z_k), where x_i, y_j and z_k are arbitrary sequences (in increasing order).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, a rectilinear grid is specified by a set of vectors, one for each Cartesian direction:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"x = [0.0, 0.1, 0.5, 1.3]\ny = sort(rand(8))\nz = [-cospi(i / 10) for i = 0:10]","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Then, a rectilinear grid file may be written as:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"which will save the file filename.vtr.","category":"page"},{"location":"grids/structured/#Image-data","page":"Structured grid formats","title":"Image data","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"The \"image data\" (or uniform grid) format is a specific case of a rectilinear grid, in which points are uniformly spaced along each of the Cartesian directions. In this case, grid points may be specified as bmx_ijk = (x_i y_j z_k). This time, each sequence is constrained to the form x_i = δx + (i - 1) Δx, where δx is an offset and Δx is the uniform spacing (this equivalently applies to y_j and z_k).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, an image data file is automatically created if all coordinates are given as AbstractRange objects. For instance, this will save a filename.vti file:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"x = 0:0.1:1\ny = 0:0.2:1\nz = range(-1, 1; length = 21)\n\nvtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/#Structured-grid","page":"Structured grid formats","title":"Structured grid","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In a structured (or curvilinear) grid, points do not need to be aligned with the Cartesian directions. In this case, grid points are specified as bmx_ijk = (x_ijk y_ijk z_ijk).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, a three-dimensional curvilinear grid may be constructed by passing a set of 3D arrays x, y and z to vtk_grid:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Ni, Nj, Nk = 6, 8, 11\nx = [i / Ni * cospi(3/2 * (j - 1) / (Nj - 1)) for i = 1:Ni, j = 1:Nj, k = 1:Nk]\ny = [i / Ni * sinpi(3/2 * (j - 1) / (Nj - 1)) for i = 1:Ni, j = 1:Nj, k = 1:Nk]\nz = [(k - 1) / Nk for i = 1:Ni, j = 1:Nj, k = 1:Nk]\n\nvtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"This will save a filename.vts file.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Alternatively, the following syntax also works (and might actually be more efficient), where xyz is a single 4-D array of dimensions (3, Ni, Nj, Nk):","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", xyz) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Again, note that all of the above works similarly in two dimensions, as one may expect.","category":"page"},{"location":"grids/structured/#Cells-in-structured-formats","page":"Structured grid formats","title":"Cells in structured formats","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In structured grids, cells are implicitly defined as the \"bricks\" whose vertices are neighbouring grid points. In three dimensions, these \"bricks\" are cuboids or parallelepipeds with 8 vertices. Similarly, in two dimensions, these are rectangles or parallelograms.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"This means that, if the grid is composed of N_i  N_j  N_k points, then the number of cells is N_c = (N_i - 1)  (N_j - 1)  (N_k - 1). Therefore, cell data attached to structured grids must be consistent with these dimensions.","category":"page"},{"location":"grids/syntax/#General-syntax","page":"General syntax","title":"General syntax","text":"","category":"section"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"The syntax for writing VTK files typically looks like the following:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"saved_files = vtk_grid(filename, points..., [cells]; kws...) do vtk\n    # add datasets here...\nend","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"Grid coordinates are passed via one or more points arguments, as detailed in Structured grid formats and Unstructured grid formats.\nThe cells argument is only relevant for unstructured grids, as detailed in Unstructured grid formats.\nData may be added to the vtk handler at the interior of the do-block. See Writing datasets for more details.\nThe returned variable saved_files is a Vector{String} containing the paths of the actual VTK files that were saved after the operation. When writing VTK dataset files (e.g. structured or unstructured grids), this contains just a single path, but this changes when one is working with metadata files such as multiblock or parallel files.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"Note that the above syntax, which uses Julia's do-block syntax is equivalent to:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"vtk = vtk_grid(filename, points..., [cells]; kws...)\n# add datasets here...\nsaved_files = vtk_save(vtk)","category":"page"},{"location":"grids/syntax/#Data-formatting-options","page":"General syntax","title":"Data formatting options","text":"","category":"section"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"By default, numerical data is written to the XML files as compressed raw binary data. This can be changed using the optional keyword arguments of vtk_grid.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"For instance, to disable both compressing and appending raw data in the case of unstructured meshes:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"vtk_grid(filename, points, cells; compress = false, append = false, ascii = false)","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"More generally:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"If append is true (default), data is written appended at the end of the XML file as raw binary data. Note that this violates the XML specification, but is allowed by VTK formats.\nOtherwise, if append is false, data is written inline. By default, inline data is written base-64 encoded, but may also be written in ASCII format (see below). Writing inline data is usually slower than writing raw binary data, and also results in larger files, but is valid according to the XML specification.\nIf ascii is true, then appended data is written in ASCII format instead of base64-encoded. This is not the default. This option is ignored if append is true.\nIf compress is true (default), data is first compressed using the CodecZlib package. Its value may also be a compression level between 1 (fast compression) and 9 (best compression). This option is ignored when writing inline data in ASCII format.","category":"page"},{"location":"grids/syntax/#Setting-the-VTK-file-version","page":"General syntax","title":"Setting the VTK file version","text":"","category":"section"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"The vtk_grid function also allows setting the VTK file version using the optional vtkversion keyword argument. This refers to the version of the VTK XML file format that is to be written, and which appears in the VTKFile element of the XML file. Different versions may be interpreted differently by ParaView. Note that this is a somewhat advanced option that may be used to solve potential issues.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"As a real-life example, say that you want to write an unstructured dataset made of Lagrange hexahedron cells. Defining each cell requires defining (1) a set of space coordinates, and (2) determining the way these coordinates connect to form the cell. The order of the points in the connectivity arrays must follow the specific node numbering expected by the VTK libraries. But the node numbering can change from one VTK version to the other. So, if one constructs the cells following the latest VTK specification, one should set the VTK file version to the newest one. See this discussion for more details.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"The vtkversion option is used as follows:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"vtk_grid(filename, points, [cells]; vtkversion = :default, etc...)","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"The vtkversion argument can take the following values:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":":default (equivalent to v\"1.0\");\n:latest (currently equivalent to v\"2.2\");\nsome other version number of the form v\"X.Y\".","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"VTK file version 1.0 is used by default for backwards compatibility and to make sure that the generated files can be read by old versions of the VTK libraries and of ParaView.","category":"page"},{"location":"API/#API-reference","page":"API Reference","title":"API reference","text":"","category":"section"},{"location":"API/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Pages = [\"API.md\"]","category":"page"},{"location":"API/#WriteVTK","page":"API Reference","title":"WriteVTK","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Modules = [WriteVTK]","category":"page"},{"location":"API/#WriteVTK.CollectionFile","page":"API Reference","title":"WriteVTK.CollectionFile","text":"CollectionFile <: VTKFile\n\nHandler for a ParaView collection file (.pvd).\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.DatasetFile","page":"API Reference","title":"WriteVTK.DatasetFile","text":"DatasetFile <: VTKFile\n\nHandler for a data-containing VTK file.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.MultiblockFile","page":"API Reference","title":"WriteVTK.MultiblockFile","text":"MultiblockFile <: VTKFile\n\nHandler for a multiblock VTK file (.vtm).\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKBlock","page":"API Reference","title":"WriteVTK.VTKBlock","text":"VTKBlock\n\nHandler for a nested block in a multiblock file.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKFile","page":"API Reference","title":"WriteVTK.VTKFile","text":"VTKFile\n\nAbstract type describing a VTK file that may be written using vtk_save.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.close-Tuple{WriteVTK.VTKFile}","page":"API Reference","title":"Base.close","text":"close(vtk::VTKFile)\n\nWrite and close VTK file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.isopen-Tuple{WriteVTK.VTKFile}","page":"API Reference","title":"Base.isopen","text":"isopen(vtk::VTKFile)\n\nCheck if VTK file is still being written.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.setindex!-Tuple{WriteVTK.DatasetFile, Any, AbstractString, VTKBase.AbstractFieldData}","page":"API Reference","title":"Base.setindex!","text":"setindex!(vtk::DatasetFile, data, name::AbstractString, [field_type])\n\nAdd a new dataset to VTK file.\n\nThe number of components of the dataset (e.g. for scalar or vector fields) is determined automatically from the input data dimensions.\n\nThe optional argument field_type should be an instance of VTKPointData, VTKCellData or VTKFieldData. It determines whether the data should be associated to grid points, cells or none. If not given, this is guessed from the input data size and the grid dimensions.\n\nExample\n\nAdd \"velocity\" dataset and time scalar to VTK file.\n\nvel = rand(3, 12, 14, 42)  # vector field\ntime = 42.0\n\nvtk = vtk_grid(...)\nvtk[\"velocity\", VTKPointData()] = vel\nvtk[\"time\", VTKFieldData()] = time\n\n# This also works, and will generally give the same result:\nvtk[\"velocity\"] = vel\nvtk[\"time\"] = time\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.setindex!-Tuple{WriteVTK.DatasetFile, Any, VTKBase.AbstractFieldData}","page":"API Reference","title":"Base.setindex!","text":"setindex!(vtk::DatasetFile, attributes, loc::AbstractFieldData)\n\nAdd attributes to point, cell, or field dataset type in a VTK file.\n\nExample\n\nAdd \"HigherOrderDegrees\" dataset and cell dataset type attribute to VTK file.\n\nvtk = vtk_grid(...)\nvtk[\"HigherOrderDegrees\", VTKCellData()] = [2; 3; 12]\nvtk[VTKCellData()] = Dict(\"HigherOrderDegrees\" => \"HigherOrderDegrees\")\n\nNote that all three are possible and equivalent:\n\nvtk[VTKCellData()] = Dict(\"HigherOrderDegrees\" => \"HigherOrderDegrees\")\nvtk[VTKCellData()] = \"HigherOrderDegrees\" => \"HigherOrderDegrees\"\nvtk[VTKCellData()] = (\"HigherOrderDegrees\" => \"HigherOrderDegrees\",)\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.add_field_data-Tuple{WriteVTK.DatasetFile, Any, AbstractString, VTKBase.AbstractFieldData}","page":"API Reference","title":"WriteVTK.add_field_data","text":"add_field_data(vtk::DatasetFile, data,\n               name::AbstractString, loc::AbstractFieldData)\n\nAdd either point or cell data to VTK file.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.add_loc_attributes-Tuple{WriteVTK.DatasetFile, Any, VTKBase.AbstractFieldData}","page":"API Reference","title":"WriteVTK.add_loc_attributes","text":"add_loc_attributes(vtk::DatasetFile, attributes, loc::AbstractFieldData)\n\nAdd attributes to point, cell, or field dataset type tags in a VTK file.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml","page":"API Reference","title":"WriteVTK.data_to_xml","text":"data_to_xml(\n    vtk::DatasetFile, xParent::XMLElement, data,\n    name::AbstractString, Nc::Union{Int,AbstractFieldData} = 1;\n    component_names::Union{AbstractVector, Nothing} = nothing\n)\n\nAdd numerical data to VTK XML file.\n\nData is written under the xParent XML node.\n\nNc may be either the number of components, or the type of field data. In the latter case, the number of components will be deduced from the data dimensions and the type of field data.\n\n\n\n\n\n","category":"function"},{"location":"API/#WriteVTK.data_to_xml_appended-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_appended","text":"data_to_xml_appended(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd appended raw binary data to VTK XML file.\n\nData is written to the vtk.buf buffer.\n\nWhen compression is enabled:\n\nthe data array is written in compressed form (obviously);\nthe header, written before the actual numerical data, is an array of HeaderType (UInt32 / UInt64) values:\n[num_blocks, blocksize, last_blocksize, compressed_blocksizes]\nAll sizes are in bytes. The header itself is not compressed, only the data is. For more details, see:\nhttp://public.kitware.com/pipermail/paraview/2005-April/001391.html\nhttp://mathema.tician.de/what-they-dont-tell-you-about-vtk-xml-binary-formats\n\nOtherwise, if compression is disabled, the header is just a single HeaderType value containing the size of the data array in bytes.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml_ascii-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_ascii","text":"data_to_xml_ascii(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd inline data to VTK XML file in ASCII format.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml_inline-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_inline","text":"data_to_xml_inline(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd inline, base64-encoded data to VTK XML file.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.multiblock_add_block","page":"API Reference","title":"WriteVTK.multiblock_add_block","text":"multiblock_add_block(\n    vtm::Union{MultiblockFile, VTKBlock},\n    vtk::VTKFile,\n    [name = \"\"],\n) -> nothing\n\nAdd a block to a MultiblockFile or a VTKBlock.\n\n\n\nmultiblock_add_block(\n    vtm::Union{MultiblockFile, VTKBlock},\n    [name = \"\"],\n) -> VTKBlock\n\nCreate a sub-block in a MultiblockFile or a VTKBlock.\n\nReturns a new VTKBlock.\n\n\n\n\n\n","category":"function"},{"location":"API/#WriteVTK.paraview_collection-Tuple{Function, Vararg{Any}}","page":"API Reference","title":"WriteVTK.paraview_collection","text":"paraview_collection(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = paraview_collection(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.paraview_collection_load-Tuple{Function, Vararg{Any}}","page":"API Reference","title":"WriteVTK.paraview_collection_load","text":"paraview_collection_load(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = paraview_collection_load(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.pvtk_grid-Tuple{AbstractString, Vararg{Any}}","page":"API Reference","title":"WriteVTK.pvtk_grid","text":"pvtk_grid(\n    filename, args...;\n    part, nparts, extents, ismain = (part == 1), ghost_level = 0,\n    kwargs...,\n)\n\nReturns a handler representing a parallel VTK file, which can be eventually written to file with vtk_save.\n\nPositional and keyword arguments in args and kwargs are passed to vtk_grid verbatim. Note that serial filenames are automatically generated from filename and from the process id part.\n\nThe following keyword arguments only apply to parallel VTK file formats.\n\nMandatory ones are:\n\npart: current (1-based) part id,\nnparts: total number of parts (only required for unstructured grids),\nextents: array specifying the partitioning of a structured grid across different processes (see below for details).\n\nOptional ones are:\n\nismain: true if the current part id part is the main (the only one that will write the .pvtk file),\nghost_level: ghost level.\n\nSpecifying extents for a structured grid\n\nFor structured grids, the partitioning of the dataset across different processes must be specified via the extents argument. This is an array where each element represents the data extent associated to a given process.\n\nFor example, for a dataset of global dimensions 15124 distributed across 4 processes, this array may look like the following:\n\nextents = [\n    ( 1:10,  1:5, 1:4),  # process 1\n    (10:15,  1:5, 1:4),  # process 2\n    ( 1:10, 5:12, 1:4),  # process 3\n    (10:15, 5:12, 1:4),  # process 4\n]\n\nSome important notes:\n\nthe extents argument must be the same for all processes;\nthe extents must overlap, or VTK / ParaView will complain when trying to open the files;\nthe length of the extents array gives the number of processes. Therefore, the nparts argument is redundant and does not need to be passed.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.pvtk_grid-Tuple{Function, Vararg{Any}}","page":"API Reference","title":"WriteVTK.pvtk_grid","text":"pvtk_grid(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = pvtk_grid(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.save_with_appended_data-Tuple{WriteVTK.DatasetFile}","page":"API Reference","title":"WriteVTK.save_with_appended_data","text":"Write VTK XML file containing appended binary data to disk.\n\nIn this case, the XML file is written manually instead of using the save_file function of LightXML, which doesn't allow to write raw binary data.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{AbstractString, AbstractVector, AbstractVector{<:VTKBase.AbstractMeshCell}, Vararg{Any}}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename,\n         xs::AbstractVector,\n         cells::AbstractVector{<:AbstractMeshCell};\n         kwargs...)\n\nCreate an unstructured mesh  image data (.vtu) file.\n\nxs is a vector of coordinates, such as a vector of SVector{3} elements.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{AbstractString, Vararg{AbstractRange}}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename, x::AbstractRange{T}, y::AbstractRange{T}, [z::AbstractRange{T}];\n         kwargs...)\n\nCreate image data (.vti) file.\n\nAlong each direction, the grid is specified in terms of an AbstractRange object.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3, 4:1.:5)  # 3D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"abc\", 1:5, 2:1.:3, range(4, 5; length = 3))  # different kinds of ranges\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3)  # 2D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"def\",\n                      LinRange(0., 5., 10),\n                      LinRange(0., 2π, 16),\n                      LinRange(1., 10., 12))\nVTK file 'def.vti' (ImageData file, open)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{Function, Vararg{Any}}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = vtk_grid(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{Union{WriteVTK.MultiblockFile, WriteVTK.VTKBlock}, AbstractString, Vararg{Any}}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(vtm::Union{MultiblockFile, VTKBlock}, [filename], griddata...; kwargs...)\n\nCreate new dataset file that is added to an existent multiblock file. The VTK grid is specified by the elements of griddata.\n\nIf the filename is not given, it is determined automatically from the filename associated to vtm and the number of existent blocks.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{AbstractString, AbstractMatrix{T}, AbstractVector{<:VTKBase.AbstractMeshCell}, Vararg{Any}}} where T","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename,\n         X::AbstractMatrix,\n         cells::AbstractVector{<:AbstractMeshCell};\n         kwargs...)\n\nCreate an unstructured mesh  image data (.vtu) file.\n\nX is a matrix with each column containing the Cartesian coordinates of a point\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}, AbstractVector{<:VTKBase.AbstractMeshCell}, Vararg{Any}}} where T","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename,\n         x::AbstractVector{T}, [y::AbstractVector{T}, [z::AbstractVector{T}]],\n         cells::AbstractVector{<:AbstractMeshCell};\n         kwargs...) where {T<:Number}\n\nCreate an unstructured mesh image data (.vtu) file.\n\nx, y and z are vectors of containing the corresponding Cartesian coordinates of each point.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}, AbstractVector{T}}, Tuple{AbstractString, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString,\n         x::AbstractVector{T}, y::AbstractVector{T}, [z::AbstractVector{T}];\n         kwargs...)\n\nCreate 2D or 3D rectilinear grid (.vtr) file.\n\nCoordinates are specified by separate vectors x, y, z.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", [0., 0.2, 0.5], collect(-2.:0.2:3), [1., 2.1, 2.3])\nVTK file 'abc.vtr' (RectilinearGrid file, open)\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_multiblock-Tuple{AbstractString}","page":"API Reference","title":"WriteVTK.vtk_multiblock","text":"vtk_multiblock([f::Function], filename) -> MultiblockFile\n\nInitialise VTK multiblock file, linking multiple VTK dataset files.\n\nReturns a handler for a multiblock file. To recursively save the multiblock file and linked dataset files, call vtk_save on the returned handler.\n\nNote that vtk_save is implicitly called if the optional f argument is passed. This is in particular what happens when using the do-block syntax.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_multiblock-Tuple{Function, Vararg{Any}}","page":"API Reference","title":"WriteVTK.vtk_multiblock","text":"vtk_multiblock(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = vtk_multiblock(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_save-Tuple{WriteVTK.MultiblockFile}","page":"API Reference","title":"WriteVTK.vtk_save","text":"vtk_save(vtm::MultiblockFile)\n\nSave and close multiblock file (.vtm). The VTK files included in the multiblock file are also saved.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_surface","page":"API Reference","title":"WriteVTK.vtk_surface","text":"vtk_surface([f::Function], filename, xs, ys, zs; kwargs...)\n\nCreate unstructured grid file (\".vtu\") representing a surface plot of a 2D function on coordinates (xs, ys) with values zs.\n\nThe coordinates xs and ys can be given as:\n\n1D arrays of respective dimensions Nx and Ny (for regular grids);\n2D arrays of dimensions (Nx, Ny) (for irregular grids).\n\nThe values zs should be given in a 2D array of dimensions (Nx, Ny).\n\nIncluding additional data\n\nOptionally, one can write additional data to the generated file via the function f, which works in the same way as for vtk_grid.\n\nAs an example, it is common to colour surface plots by the height z. To do this, one should write the zs matrix as point data:\n\njulia> xs = 0:0.5:10; ys = 0:1.0:20;\n\njulia> zs = @. cos(xs) + sin(ys');\n\njulia> vtk_surface(\"surf\", xs, ys, zs) do vtk\n           vtk[\"z_values\"] = zs\n       end\n\nNote that the included data must have dimensions (Nx, Ny) (for point data) or (Nx - 1, Ny - 1) (for cell data).\n\n\n\n\n\n","category":"function"},{"location":"API/#WriteVTK.vtk_write_array-Union{Tuple{S}, Tuple{A}, Tuple{N}, Tuple{M}, Tuple{T}, Tuple{AbstractString, Tuple{Vararg{A, M}}, Tuple{Vararg{S, M}}}} where {T<:Real, M, N, A<:AbstractArray{T, N}, S<:AbstractString}","page":"API Reference","title":"WriteVTK.vtk_write_array","text":"vtk_write_array(filename, arrays, labels)\nvtk_write_array(filename, array; label = \"array\")\n\nWrite Julia arrays to a VTK image data file (.vti).\n\nUseful for general visualisation of arrays. The input can be a 2D or 3D array.\n\nMultiple arrays can be given as a tuple. For instance,\n\nvtk_write_array(filename, (u, v), (\"u\", \"v\"))\n\nIn that case, the arrays must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"tools/surface/#Generating-surface-plots","page":"Generating surface plots","title":"Generating surface plots","text":"","category":"section"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"Surface plots can be used to represent two-dimensional data. WriteVTK includes the convenience function vtk_surface for visualising surface plots via VTK files. This works in a similar way to surface plots in many plotting packages, e.g. Makie.","category":"page"},{"location":"tools/surface/#Basic-usage","page":"Generating surface plots","title":"Basic usage","text":"","category":"section"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"The vtk_surface function takes the coordinates xs and ys as well as the heights zs of the data. Other than that, it works in the same way as vtk_grid:","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"julia> using WriteVTK\n\njulia> xs = 0:0.5:10; ys = 0:1.0:20;\n\njulia> zs = @. cos(xs) + sin(ys');\n\njulia> vtk = vtk_surface(\"surf\", xs, ys, zs)\nVTK file 'surf.vtu' (UnstructuredGrid file, open)\n\njulia> vtk_save(vtk)\n1-element Vector{String}:\n \"surf.vtu\"","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"This will generate a surf.vtu file (corresponding to a VTK unstructured grid) ready to be visualised:","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"(Image: Visualisation of basic surface plot.)","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"Note that the above example represents a regular 2D grid. For irregular grids, it is also possible to pass xs and ys as matrices instead of vectors.","category":"page"},{"location":"tools/surface/#Attaching-more-data","page":"Generating surface plots","title":"Attaching more data","text":"","category":"section"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"In the above example, the dataset does not include any data that could be readily used to colour the surface. In surface plots, it is common to colour the surface by its own height. This can be easily achieved by writing the zs matrix as point data when creating the VTK file:","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"julia> vtk_surface(\"surf2\", xs, ys, zs) do vtk\n           vtk[\"z_values\"] = zs\n       end\n1-element Vector{String}:\n \"surf2.vtu\"","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"(Image: Visualisation of surface plot with colours.)","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"Above we have used the do-block syntax in the very same way it can be done with vtk_grid. Of course, the same syntax can be used to add as many datasets as one wants.","category":"page"},{"location":"tools/surface/","page":"Generating surface plots","title":"Generating surface plots","text":"For more details, see the vtk_surface documentation.","category":"page"},{"location":"tools/readvtk/#Reading-VTK-files","page":"Reading VTK files","title":"Reading VTK files","text":"","category":"section"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"The ReadVTK.jl package, mainly written by Michael Schlottke-Lakemper and the Trixi authors, may be used to read VTK files.","category":"page"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"Note that ReadVTK.jl is specifically meant for reading VTK XML files generated by WriteVTK.jl, and may not be able to read VTK files coming from other sources.","category":"page"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"See the ReadVTK.jl documentation for details on what can and cannot be done with it.","category":"page"},{"location":"metadata/paraview_collections/#ParaView-collections","page":"ParaView collections","title":"ParaView collections","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"A ParaView collection file (extension .pvd) represents a time series of VTK files. This may be used for visualising simulation results at different time steps, and in particular for creating simulation movies.","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"A pvd file is initialised using paraview_collection:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd = paraview_collection(\"my_pvd_file\")","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"By default this overwrites existent pvd files. To append new datasets to an existent pvd file, set the append option to true:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd = paraview_collection(\"my_pvd_file\"; append = true)","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"VTK files are then added to the pvd file with","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd[time] = vtk","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"or equivalently","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"collection_add_timestep(pvd, vtk, time)","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"Here, time is a real number that represents the current time (or timestep) in the simulation. Note that both options implicitly call vtk_save(vtk) so adding the VTK file to the collection must be done after adding data to the file.","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"When all the files are added to the pvd file, it can be saved using:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"vtk_save(pvd)","category":"page"},{"location":"metadata/paraview_collections/#Working-example","page":"ParaView collections","title":"Working example","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"The following is a full working example using the do-block syntax:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"x, y, z = 0:10, 1:6, 2:0.1:3\ntimes = range(0, 10; step = 0.5)\n\nsaved_files = paraview_collection(\"full_simulation\") do pvd\n    for (n, time) ∈ enumerate(times)\n        vtk_grid(\"timestep_$n\", x, y, z) do vtk\n            vtk[\"Pressure\"] = rand(length(x), length(y), length(z))\n            pvd[time] = vtk\n        end\n    end\nend","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"In this example, the saved files are:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"julia> saved_files\n22-element Vector{String}:\n \"full_simulation.pvd\"\n \"timestep_1.vti\"\n \"timestep_2.vti\"\n \"timestep_3.vti\"\n \"timestep_4.vti\"\n \"timestep_5.vti\"\n \"timestep_6.vti\"\n \"timestep_7.vti\"\n ⋮\n \"timestep_15.vti\"\n \"timestep_16.vti\"\n \"timestep_17.vti\"\n \"timestep_18.vti\"\n \"timestep_19.vti\"\n \"timestep_20.vti\"\n \"timestep_21.vti\"","category":"page"},{"location":"metadata/paraview_collections/#Acknowledgements","page":"ParaView collections","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"Thanks to Patrick Belliveau for the initial implementation of ParaView collection functionality, and to Sebastian Pech for additional improvements.","category":"page"},{"location":"#WriteVTK.jl","page":"Home","title":"WriteVTK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package allows to write VTK XML files for visualisation of multidimensional datasets using tools such as ParaView. A wide range of VTK formats is supported, including different kinds of structured and unstructured grids, as well as metadata files for describing time series or multi-block domains.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WriteVTK can be installed using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add WriteVTK","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The vtk_grid function is the entry point for creating different kinds of VTK files. In the simplest cases, one just passes coordinate information to this function. WriteVTK.jl then determines the VTK format that is more adapted for the provided data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, it is natural in Julia to describe a uniform three-dimensional grid (with regularly-spaced increments) as a set of ranges:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = 0:0.1:1\ny = 0:0.2:1\nz = -1:0.05:1","category":"page"},{"location":"","page":"Home","title":"Home","text":"This specific way of specifying coordinates is compatible with the image data VTK format, which has the .vti extension. The following creates such a file, with some scalar data attached to each point:","category":"page"},{"location":"","page":"Home","title":"Home","text":"vtk_grid(\"fields\", x, y, z) do vtk\n    vtk[\"temperature\"] = rand(length(x), length(y), length(z))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will create a fields.vti file with the data. Note that the file extension should not be included in the filename, as it will be attached automatically according to the dataset type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By changing the coordinate specifications, the above can be naturally generalised to non-uniform grid spacings and to curvilinear and unstructured grids. In each case, the correct kind of VTK file will be generated.","category":"page"},{"location":"#Supported-VTK-formats","page":"Home","title":"Supported VTK formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package attempts to implement writers for all VTK XML formats described in the VTK specification. Note that legacy (non-XML) files are not supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported dataset formats include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"image data (.vti),\nrectilinear grid (.vtr),\nstructured (or curvilinear) grid (.vts),\nunstructured grid (.vtu),\npolydata (.vtp, a specific type of unstructured grid).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, the following metadata formats are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multiblock files (.vtm),\nParaView collections (.pvd, typically used for time series),\nparallel files (.pvt*).","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is mainly written and maintained by Juan Ignacio Polanco, with many important contributions by Fredrik Ekre. Moreover, a number of authors have implemented additional functionality, and are acknowledged throughout the documentation.","category":"page"}]
}
