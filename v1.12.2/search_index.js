var documenterSearchIndex = {"docs":
[{"location":"grids/datasets/#Writing-datasets","page":"Writing datasets","title":"Writing datasets","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"In VTK files, datasets represent scalar, vector or tensor quantities that one may want to visualise. These quantities are generally attached to either grid points or cells.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The simplest syntax for writing datasets to a file is as follows:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\n\nvtk_grid(\"fields\", x, y, z) do vtk\n    vtk[\"Temperature\"] = rand(Nx, Ny, Nz)              # scalar field attached to points\n    vtk[\"Pressure\"] = rand(Nx - 1, Ny - 1, Nz - 1)     # scalar field attached to cells\n    vtk[\"Velocity\"] = rand(3, Nx, Ny, Nz)              # vector field attached to points\n    vtk[\"VelocityGradients\"] = rand(3, 3, Nx, Ny, Nz)  # 3×3 tensor field attached to points\n    vtk[\"date\"] = \"31/10/2021\"                         # metadata (\"field data\" in VTK)\n    vtk[\"time\"] = 0.42                                 # metadata (\"field data\" in VTK)\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"In the above example, WriteVTK automatically decides whether data is to be attached to grid points or to grid cells depending on the dimensions of the input. In particular, note that the Pressure field is attached to cells instead of points, since it has dimensions (N_x - 1)  (N_y - 1)  (N_z - 1), which is the number of cells in structured files (see Cells in structured formats). For more control, see Dataset types below.","category":"page"},{"location":"grids/datasets/#Passing-tuples-of-arrays","page":"Writing datasets","title":"Passing tuples of arrays","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"Note that, in the example above, the Velocity vector field is passed as a single 3  N_x  N_y  N_z array, which is the layout ultimately used in VTK formats. In some applications, one may instead prefer to work with vector fields as a collection of separate scalar fields, or similarly as an array of dimensions N_x  N_y  N_z  3.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"To avoid unnecessary allocations in transposing the data to 3  N_x  N_y  N_z format, WriteVTK also allows passing vector and tensor fields as tuples of arrays. For example:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\nvx, vy, vz = rand(Nx, Ny, Nz), rand(Nx, Ny, Nz), rand(Nx, Ny, Nz)  # vector as separate fields\nω = rand(Nx, Ny, Nz, 3)\n∇v = rand(Nx, Ny, Nz, 3, 3)\n\nvtk_grid(\"fields_tuples\", x, y, z) do vtk\n    # Pass vectors as tuples of scalars\n    vtk[\"Velocity\"] = (vx, vy, vz)\n    vtk[\"Vorticity\"] = @views (ω[:, :, :, 1], ω[:, :, :, 2], ω[:, :, :, 3])\n\n    # Similarly for tensors\n    vtk[\"VelocityGradients\"] = @views (\n        ∇v[:, :, :, 1, 1], ∇v[:, :, :, 2, 1], ∇v[:, :, :, 3, 1],\n        ∇v[:, :, :, 1, 2], ∇v[:, :, :, 2, 2], ∇v[:, :, :, 3, 2],\n        ∇v[:, :, :, 1, 3], ∇v[:, :, :, 2, 3], ∇v[:, :, :, 3, 3],\n    )\nend","category":"page"},{"location":"grids/datasets/#Passing-arrays-of-static-arrays","page":"Writing datasets","title":"Passing arrays of static arrays","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"Alternatively, a common use case is to store vector fields as arrays of static arrays, using the StaticArrays package. This use case is naturally supported by WriteVTK:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"using StaticArrays\n\nx, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\nv = rand(SVector{3, Float64}, Nx, Ny, Nz)\n∇v = rand(SMatrix{3, 3, Float32, 9}, Nx, Ny, Nz)\n\nvtk_grid(\"fields_sarray\", x, y, z) do vtk\n    vtk[\"Velocity\"] = v\n    vtk[\"VelocityGradients\"] = ∇v\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"One may also specify grid coordinates using arrays of static arrays:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"using StaticArrays\n\nNx, Ny, Nz = 5, 6, 10\nxs = [SVector(sqrt(i) + 2j + 3k, 2i - j + k, -i + 3j - k)\n      for i = 1:Nx, j = 1:Ny, k = 1:Nz]\n\nvtk_grid(\"coords_sarray\", xs) do vtk\n    # add datasets here...\nend","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"note: (Lack of) dependencies\nNote that the WriteVTK package does not directly depend on StaticArrays, as there is no StaticArrays-specific implementation allowing for the functionality described in this section. Instead, the implementation is quite generic, and the above may also work with array types that behave similarly to StaticArrays.","category":"page"},{"location":"grids/datasets/#Dataset-types","page":"Writing datasets","title":"Dataset types","text":"","category":"section"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The syntax exposed above is high-level, in the sense that WriteVTK automatically decides on the type of dataset depending on the dimensions of the input data.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"The VTK format defines three different kinds of dataset:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"VTKPointData for data attached to grid points,\nVTKCellData for data attached to grid cells,\nVTKFieldData for everything else. This may be used to store lightweight metadata, such as time information or strings.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"For more control, one can explicitly pass an instance of VTKPointData, VTKCellData and VTKFieldData when adding a dataset to a VTK file.","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"For example:","category":"page"},{"location":"grids/datasets/","page":"Writing datasets","title":"Writing datasets","text":"x, y, z = 0:10, 1:6, 2:0.1:3\nNx, Ny, Nz = length(x), length(y), length(z)\n\nvtk_grid(\"fields_explicit\", x, y, z) do vtk\n    vtk[\"Temperature\", VTKPointData()] = rand(Nx, Ny, Nz)\n    vtk[\"Pressure\", VTKCellData()] = rand(Nx - 1, Ny - 1, Nz - 1)\n    vtk[\"Velocity\", VTKPointData()] = rand(3, Nx, Ny, Nz)\n    vtk[\"VelocityGradients\", VTKPointData()] = rand(3, 3, Nx, Ny, Nz)\n    vtk[\"date\", VTKFieldData()] = \"31/10/2021\"\n    vtk[\"time\", VTKFieldData()] = 0.42\nend","category":"page"},{"location":"metadata/multiblock/#Multiblock-files","page":"Multiblock files","title":"Multiblock files","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Multiblock files (.vtm) are XML VTK files that can point to multiple other VTK files. They can be useful when working with complex geometries that are composed of multiple sub-domains.","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"To generate a multiblock file, it must first be initialised using vtk_multiblock:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"vtm = vtk_multiblock(\"my_vtm_file\")","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Then, each sub-grid can be generated with vtk_grid using vtm as the first argument:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# First block.\nlet vtk = vtk_grid(vtm, x1, y1, z1)\n    vtk[\"Pressure\"] = p1\nend\n\n# Second block.\nlet vtk = vtk_grid(vtm, x2, y2, z2)\n    vtk[\"Pressure\"] = p2\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Additional blocks can also be added to the multiblock file with multiblock_add_block, which can contain any of the VTK files that WriteVTK supports:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# Create a block named \"my_multiblock\" and add it to `vtm`.\nblock = multiblock_add_block(vtm, \"my_multiblock\")\n\n# Add a VTK file to `block`.\nlet vtk = vtk_grid(block, \"another_file\", x3, y3, z3)\n    vtk[\"Pressure\"] = p3\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Blocks can be nested arbitrarily:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"# Add more blocks.\nanother_block = multiblock_add_block(block, \"my_multiblock-block\")\nyet_another_block = multiblock_add_block(another_block, \"my_multiblock-block-block\")","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"And more VTK files may be added to the sub-blocks:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"vtk = vtk_grid(yet_another_block, \"my_deeply_nested_file\", x4, y4, z4)","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Finally, only the multiblock file needs to be saved explicitly:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"outfiles = vtk_save(vtm)","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"WriteVTK will write out a multiblock VTK file that looks like something like this (in addition to all the VTK files contained in the multiblock file):","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<VTKFile type=\"vtkMultiBlockDataSet\" version=\"1.0\" byte_order=\"LittleEndian\">\n  <vtkMultiBlockDataSet>\n    <DataSet index=\"0\" file=\"my_vtm_file_1.vti\"/>\n    <DataSet index=\"1\" file=\"my_vtm_file_2.vti\"/>\n    <Block index=\"2\" name=\"my_multiblock\">\n      <DataSet index=\"0\" file=\"another_file.vti\" name=\"another_file\"/>\n      <Block index=\"1\" name=\"my_multiblock-block\">\n        <Block index=\"0\" name=\"my_multiblock-block-block\">\n          <DataSet index=\"0\" file=\"my_deeply_nested_file.vti\" name=\"my_deeply_nested_file\"/>\n        </Block>\n      </Block>\n    </Block>\n  </vtkMultiBlockDataSet>\n</VTKFile>","category":"page"},{"location":"metadata/multiblock/#Working-example","page":"Multiblock files","title":"Working example","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"The full above example may also be written using the do-block syntax as follows:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"x1, y1, z1 = 0:10, 1:6, 2:0.1:3\nx2, y2, z2 = 10:14, 1:0.5:4, 2:0.1:3\nx3, y3, z3 = 14:0.1:15, 3:0.5:4, 1:0.1:1.5\nx4, y4, z4 = [0, 0.3, 1.2], range(0, 1, length = 3), [1, 1.3, 2]\n\nsaved_files = vtk_multiblock(\"full_domain\") do vtm\n    # First block.\n    # By default, since the name of the file is not given, the file \"full_domain_1.vti\" will be saved.\n    vtk_grid(vtm, x1, y1, z1) do vtk\n        vtk[\"Pressure\"] = rand(length(x1), length(y1), length(z1))\n    end\n\n    # Second block.\n    # Note that we can override the default filename.\n    # In this case, the filename will be \"block_2.vti\" instead of \"full_domain_2.vti\".\n    vtk_grid(vtm, \"block_2\", x2, y2, z2) do vtk\n        vtk[\"Pressure\"] = rand(length(x2), length(y2), length(z2))\n    end\n\n    # Create a block named \"my_multiblock\" and add it to `vtm`.\n    block = multiblock_add_block(vtm, \"my_multiblock\")\n\n    # Add a VTK file to `block`.\n    vtk_grid(block, \"another_file\", x3, y3, z3) do vtk\n        vtk[\"Pressure\"] = rand(length(x3), length(y3), length(z3))\n    end\n\n    # Add nested blocks.\n    another_block = multiblock_add_block(block, \"my_multiblock-block\")\n    yet_another_block = multiblock_add_block(another_block, \"my_multiblock-block-block\")\n\n    vtk_grid(yet_another_block, \"my_deeply_nested_file\", x4, y4, z4) do vtk\n        vtk[\"Pressure\"] = rand(length(x4), length(y4), length(z4))\n    end\nend","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"This will generate the following files:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"julia> saved_files\n5-element Vector{String}:\n \"full_domain.vtm\"\n \"full_domain_1.vti\"\n \"block_2.vti\"\n \"another_file.vti\"\n \"my_deeply_nested_file.vtr\"","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"By opening full_domain.vtm in ParaView, one can get the following picture:","category":"page"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"(Image: Visualisation of multiblock file)","category":"page"},{"location":"metadata/multiblock/#Acknowledgements","page":"Multiblock files","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/multiblock/","page":"Multiblock files","title":"Multiblock files","text":"Thanks to Daniel Ingraham for the implementation of recursive multiblock functionality.","category":"page"},{"location":"metadata/parallel/#Parallel-files","page":"Parallel files","title":"Parallel files","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The parallel file formats do not actually store any data in the file. Instead, the data is broken into pieces, each of which is stored in a serial file, and an extra header file is created containing pointers to the corresponding serial files. The header file extension is the serial extension pre-appended with a p. For instance, for serial vtu files, the corresponding header file extension is pvtu.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"note: Supported dataset types\nFor now, parallel file formats have only been tested for unstructured grid formats (.vtu), and are currently unlikely to work for other kinds of datasets. Feel free to open an issue or to submit a PR to add support for other dataset types.","category":"page"},{"location":"metadata/parallel/#Generating-a-parallel-data-file","page":"Parallel files","title":"Generating a parallel data file","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The parallel header file and the corresponding serial files are generated using the pvtk_grid function. Its signature is","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"pvtk_grid(\n    args...;\n    part,\n    nparts,\n    ismain = (part == 1),\n    ghost_level = 0,\n    kwargs...,\n)","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"which returns a handler representing a parallel VTK file that can be appended with cell and point data and eventually written to disk with vtk_save as usual. In an MPI job, vtk_save will cause each rank to write a serial file and just a single rank (e.g., rank 0) will write the header file.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Positional and keyword arguments in args and kwargs are passed to vtk_grid verbatim in order to generate the serial files (with the exception of file names that are augmented with the corresponding part id).","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"The extra keyword arguments only apply to parallel VTK file formats.","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Mandatory ones are:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"part current (1-based) part id (typically MPI rank + 1),\nnparts total number of parts (typically the MPI communicator size).","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Optional ones are:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"ismain true if the current part id part is the main (the only one that will write the header file),\nghost_level ghost level.","category":"page"},{"location":"metadata/parallel/#Example","page":"Parallel files","title":"Example","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"This generates the header file and a single serial file:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"cells = [\n    MeshCell(VTKCellTypes.VTK_TRIANGLE, [1, 4, 2]),\n    MeshCell(VTKCellTypes.VTK_QUAD, [2, 4, 3, 5]),\n]\n\nx = rand(5)\ny = rand(5)\n\nsaved_files = pvtk_grid(\"simulation\", x, y, cells; part = 1, nparts = 1) do pvtk\n    pvtk[\"Pressure\"] = x\n    pvtk[\"Processor\"] = rand(2)\nend","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"In this example, saved_files lists the two files saved at the end of the do-block:","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"julia> saved_files\n2-element Vector{String}:\n \"simulation.pvtu\"\n \"simulation/simulation_1.vtu\"","category":"page"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Note that the files containing the actual data (in this case simulation_1.vtu) are stored in a separate simulation directory.","category":"page"},{"location":"metadata/parallel/#Acknowledgements","page":"Parallel files","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/parallel/","page":"Parallel files","title":"Parallel files","text":"Thanks to Francesc Verdugo and Alberto F. Martin for the initial parallel file format implementation.","category":"page"},{"location":"tools/write_array/#Visualising-Julia-arrays","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"A convenience function, vtk_write_array, is provided to quickly save Julia arrays as image data:","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"p = rand(100, 100, 100)\nvtk_write_array(\"filename\", p, \"Pressure\")","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"This may be useful for visualising the data contained in a Julia array.","category":"page"},{"location":"tools/write_array/#Writing-multiple-arrays","page":"Visualising Julia arrays","title":"Writing multiple arrays","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"Multiple arrays can be given as a tuple. For instance,","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"vtk_write_array(\"filename\", (u, v), (\"u\", \"v\"))","category":"page"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"In that case, the arrays must have the same dimensions.","category":"page"},{"location":"tools/write_array/#Acknowledgements","page":"Visualising Julia arrays","title":"Acknowledgements","text":"","category":"section"},{"location":"tools/write_array/","page":"Visualising Julia arrays","title":"Visualising Julia arrays","text":"Thanks to Júlio Hoffimann for adding this functionality.","category":"page"},{"location":"grids/unstructured/#Unstructured-grid-formats","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Unstructured grids are those in which each grid point (or vertex) can be arbitrarily placed in space. Such points are generally connected to define cells of different shapes.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"In general, unstructured grids require the specification of grid points, and of the cells that define the mesh. A cell is specified by a shape (tetrahedron, triangle, ...) and by a list of grid points (the connectivity vector) that define the cell. In WriteVTK, a cell is described by a MeshCell object.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"An unstructured grid is then defined by passing a list of grid coordinates and of cells to vtk_grid, as in","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"vtk_grid(\"filename\", points, cells)","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"As detailed in the next sections, depending on the actual kind of MeshCells contained in cells, either an unstructured grid (.vtu) or a polydata grid (.vtp) file is written.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Above, points is an array with the point locations, of dimensions (dim, num_points) where dim is the spatial dimension (1, 2 or 3) and num_points the number of points. Alternatively, grid points may be specified by passing separate 1D vectors of length num_points, as in","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"vtk_grid(\"filename\", x, y, z, cells)","category":"page"},{"location":"grids/unstructured/#Defining-cells","page":"Unstructured grid formats","title":"Defining cells","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"A single cell is created as","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"cell = MeshCell(cell_type, connectivity)","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Here, cell_type defines the cell shape, while connectivity is a list of grid point indices determining the cell location. Note that the connectivity indices are one-based (as opposed to zero-based), following the convention in Julia.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"For example, the following creates a triangular cell:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"cell = MeshCell(VTKCellTypes.VTK_TRIANGLE, (1, 2, 4))","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Note that, since this is a triangle, the connectivity vector must contain three elements (corresponding to the three vertices of the triangle), and an error is thrown if that is not the case.","category":"page"},{"location":"grids/unstructured/#Unstructured-grid","page":"Unstructured grid formats","title":"Unstructured grid","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The cell types available for the unstructured grid format are those listed in the VTK specification (figures 2 and 3). For convenience, WriteVTK includes a VTKCellTypes module that contains these definitions. For instance, a triangle is associated to the cell type VTKCellTypes.VTK_TRIANGLE.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The following example creates a filename.vtu file with two cells:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"points = rand(3, 5)  # 5 points in three dimensions\ncells = [MeshCell(VTKCellTypes.VTK_TRIANGLE, [1, 4, 2]),\n         MeshCell(VTKCellTypes.VTK_QUAD,     [2, 4, 3, 5])]\n\nvtk_grid(\"filename\", points, cells) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/unstructured/#Polydata-grid","page":"Unstructured grid formats","title":"Polydata grid","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"This is a specific type of unstructured grid that is restricted to a small subset of cell types, namely vertices, lines, triangle strips and polygons. In WriteVTK, these shapes are respectively identified by the singleton types PolyData.Verts, PolyData.Lines, PolyData.Strips and PolyData.Polys (see also the PolyData module).","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Polydata cells are specified by passing one of the above types to MeshCell. For instance, the following specifies a line passing by 4 points of the grid:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"line = MeshCell(PolyData.Lines(), [3, 4, 7, 2])","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Similarly to unstructured grids, a VTK file is created by passing vectors of cells to vtk_grid. The difference is that one can pass multiple vectors (one for each cell type), and that each vector may only contain a single cell type.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"Example:","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"# Create lists of lines and polygons connecting different points in space\npoints = rand(3, 100)  # (x, y, z) locations\nlines = [MeshCell(PolyData.Lines(), (i, i + 1, i + 4)) for i in (3, 5, 42)]\npolys = [MeshCell(PolyData.Polys(), i:(i + 6)) for i = 1:3:20]\n\nvtk_grid(\"my_vtp_file\", points, lines, polys) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"warning: Known issue\nWhen the polygonal dataset contains multiple kinds of cells (e.g. both lines and polygons), cell data is not correctly parsed by the VTK libraries, and as a result it cannot be visualised in ParaView. The problem doesn't happen with point data. This seems to be a very old VTK issue.","category":"page"},{"location":"grids/unstructured/#Polyhedron-cells","page":"Unstructured grid formats","title":"Polyhedron cells","text":"","category":"section"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"WriteVTK also supports the creation of unstructured VTK files containing polyhedron cells. The specificity of polyhedron cells is that they require the specification not only of a connectivity vector, but also of a list of faces constituting the polyhedron. To specify a polyhedron cell, instead of using the MeshCell type, one should create an instance of VTKPolyhedron.","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"The following simple example creates a cube as a polyhedron cell (see also test/polyhedron_cube.jl for an example with two cubes):","category":"page"},{"location":"grids/unstructured/","page":"Unstructured grid formats","title":"Unstructured grid formats","text":"# Vertices of the cube\npoints = permutedims(Float32[\n    -1 -1 -1;\n     1 -1 -1;\n     1  1 -1;\n    -1  1 -1;\n    -1 -1  1;\n     1 -1  1;\n     1  1  1;\n    -1  1  1;\n])\n\n# Create a single polyhedron cell describing the cube\ncells = [\n    VTKPolyhedron(\n        1:8,           # connectivity vector\n        (1, 4, 3, 2),  # face 1\n        (1, 5, 8, 4),  # face 2\n        (5, 6, 7, 8),  # etc...\n        (6, 2, 3, 7),\n        (1, 2, 6, 5),\n        (3, 4, 8, 7),\n    ),\n]\n\n# Finally, create a simple VTK file\nvtk_grid(\"polyhedron_cube\", points, cells) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/#Structured-grid-formats","page":"Structured grid formats","title":"Structured grid formats","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Structured grids are those in which each grid point (or vertex) can be specified by a set of indices such as (i, j, k) in three dimensions.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In general, structured grids in WriteVTK are generated using one of the following syntaxes:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", x, y, z; kwargs...)\nvtk_grid(\"filename\", xyz; kwargs...)","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Note that, while all examples here are done in three-dimensions, things also work as expected in two dimensions (e.g. by only passing x and y coordinates to vtk_grid).","category":"page"},{"location":"grids/structured/#Rectilinear-grid","page":"Structured grid formats","title":"Rectilinear grid","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In a rectilinear grid, points are aligned with the Cartesian directions. In this case, grid points may be specified by bmx_ijk = (x_i y_j z_k), where x_i, y_j and z_k are arbitrary sequences (in increasing order).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, a rectilinear grid is specified by a set of vectors, one for each Cartesian direction:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"x = [0.0, 0.1, 0.5, 1.3]\ny = sort(rand(8))\nz = [-cospi(i / 10) for i = 0:10]","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Then, a rectilinear grid file may be written as:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"which will save the file filename.vtr.","category":"page"},{"location":"grids/structured/#Image-data","page":"Structured grid formats","title":"Image data","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"The \"image data\" (or uniform grid) format is a specific case of a rectilinear grid, in which points are uniformly spaced along each of the Cartesian directions. In this case, grid points may be specified as bmx_ijk = (x_i y_j z_k). This time, each sequence is constrained to the form x_i = δx + (i - 1) Δx, where δx is an offset and Δx is the uniform spacing (this equivalently applies to y_j and z_k).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, an image data file is automatically created if all coordinates are given as AbstractRange objects. For instance, this will save a filename.vti file:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"x = 0:0.1:1\ny = 0:0.2:1\nz = range(-1, 1; length = 21)\n\nvtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/#Structured-grid","page":"Structured grid formats","title":"Structured grid","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In a structured (or curvilinear) grid, points do not need to be aligned with the Cartesian directions. In this case, grid points are specified as bmx_ijk = (x_ijk y_ijk z_ijk).","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In WriteVTK, a three-dimensional curvilinear grid may be constructed by passing a set of 3D arrays x, y and z to vtk_grid:","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Ni, Nj, Nk = 6, 8, 11\nx = [i / Ni * cospi(3/2 * (j - 1) / (Nj - 1)) for i = 1:Ni, j = 1:Nj, k = 1:Nk]\ny = [i / Ni * sinpi(3/2 * (j - 1) / (Nj - 1)) for i = 1:Ni, j = 1:Nj, k = 1:Nk]\nz = [(k - 1) / Nk for i = 1:Ni, j = 1:Nj, k = 1:Nk]\n\nvtk_grid(\"filename\", x, y, z) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"This will save a filename.vts file.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Alternatively, the following syntax also works (and might actually be more efficient), where xyz is a single 4-D array of dimensions (3, Ni, Nj, Nk):","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"vtk_grid(\"filename\", xyz) do vtk\n    # add datasets...\nend","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"Again, note that all of the above works similarly in two dimensions, as one may expect.","category":"page"},{"location":"grids/structured/#Cells-in-structured-formats","page":"Structured grid formats","title":"Cells in structured formats","text":"","category":"section"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"In structured grids, cells are implicitly defined as the \"bricks\" whose vertices are neighbouring grid points. In three dimensions, these \"bricks\" are cuboids or parallelepipeds with 8 vertices. Similarly, in two dimensions, these are rectangles or parallelograms.","category":"page"},{"location":"grids/structured/","page":"Structured grid formats","title":"Structured grid formats","text":"This means that, if the grid is composed of N_i  N_j  N_k points, then the number of cells is N_c = (N_i - 1)  (N_j - 1)  (N_k - 1). Therefore, cell data attached to structured grids must be consistent with these dimensions.","category":"page"},{"location":"grids/syntax/#General-syntax","page":"General syntax","title":"General syntax","text":"","category":"section"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"The syntax for writing VTK files typically looks like the following:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"saved_files = vtk_grid(filename, points..., [cells]; kws...) do vtk\n    # add datasets here...\nend","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"Grid coordinates are passed via one or more points arguments, as detailed in Structured grid formats and Unstructured grid formats.\nThe cells argument is only relevant for unstructured grids, as detailed in Unstructured grid formats.\nData may be added to the vtk handler at the interior of the do-block. See Writing datasets for more details.\nThe returned variable saved_files is a Vector{String} containing the paths of the actual VTK files that were saved after the operation. When writing VTK dataset files (e.g. structured or unstructured grids), this contains just a single path, but this changes when one is working with metadata files such as multiblock or parallel files.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"Note that the above syntax, which uses Julia's do-block syntax is equivalent to:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"vtk = vtk_grid(filename, points..., [cells]; kws...)\n# add datasets here...\nsaved_files = vtk_save(vtk)","category":"page"},{"location":"grids/syntax/#Supported-options","page":"General syntax","title":"Supported options","text":"","category":"section"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"By default, numerical data is written to the XML files as compressed raw binary data. This can be changed using the optional keyword arguments of vtk_grid.","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"For instance, to disable both compressing and appending raw data in the case of unstructured meshes:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"vtk_grid(filename, points, cells; compress = false, append = false, ascii = false)","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"More generally:","category":"page"},{"location":"grids/syntax/","page":"General syntax","title":"General syntax","text":"If append is true (default), data is written appended at the end of the XML file as raw binary data. Note that this violates the XML specification, but is allowed by VTK formats.\nOtherwise, if append is false, data is written inline. By default, inline data is written base-64 encoded, but may also be written in ASCII format (see below). Writing inline data is usually slower than writing raw binary data, and also results in larger files, but is valid according to the XML specification.\nIf ascii is true, then appended data is written in ASCII format instead of base64-encoded. This is not the default. This option is ignored if append is true.\nIf compress is true (default), data is first compressed using the CodecZlib package. Its value may also be a compression level between 1 (fast compression) and 9 (best compression). This option is ignored when writing inline data in ASCII format.","category":"page"},{"location":"API/#API-reference","page":"API Reference","title":"API reference","text":"","category":"section"},{"location":"API/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Pages = [\"API.md\"]","category":"page"},{"location":"API/#WriteVTK","page":"API Reference","title":"WriteVTK","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Modules = [WriteVTK]","category":"page"},{"location":"API/#WriteVTK.VTKDataType","page":"API Reference","title":"WriteVTK.VTKDataType","text":"VTKDataType\n\nUnion of data types allowed by VTK.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.AbstractFieldData","page":"API Reference","title":"WriteVTK.AbstractFieldData","text":"AbstractFieldData\n\nAbstract type representing any kind of dataset.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.AbstractMeshCell","page":"API Reference","title":"WriteVTK.AbstractMeshCell","text":"AbstractMeshCell\n\nAbstract type specifying a VTK cell.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.AbstractVTKDataset","page":"API Reference","title":"WriteVTK.AbstractVTKDataset","text":"AbstractVTKDataset\n\nAbstract type representing any structured or unstructured VTK dataset.\n\nThe dataset classification is described in the VTK file format specification, page 12.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.CollectionFile","page":"API Reference","title":"WriteVTK.CollectionFile","text":"CollectionFile <: VTKFile\n\nHandler for a ParaView collection file (.pvd).\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.DatasetFile","page":"API Reference","title":"WriteVTK.DatasetFile","text":"DatasetFile <: VTKFile\n\nHandler for a data-containing VTK file.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.MeshCell","page":"API Reference","title":"WriteVTK.MeshCell","text":"MeshCell <: AbstractMeshCell\n\nSingle cell element in unstructured or polygonal grid.\n\nIt is characterised by a cell type (for instance, VTKCellType.TRIANGLE or PolyData.Strips) and by a connectivity vector determining the points on the grid defining this cell.\n\n\n\nMeshCell(cell_type, connectivity)\n\nDefine a single cell element of an unstructured grid.\n\nThe cell_type argument characterises the type of cell (e.g. vertex, triangle, hexaedron, ...):\n\ncell types for unstructured datasets are defined in the VTKCellTypes\n\nmodule;\n\ncell types for polygonal datasets are defined in the PolyData module.\n\nThe connectivity argument is a vector or tuple containing the indices of the points passed to vtk_grid which define this cell.\n\nExample\n\nDefine a triangular cell passing by points with indices [3, 5, 42].\n\njulia> cell = MeshCell(VTKCellTypes.VTK_TRIANGLE, (3, 5, 42))\nMeshCell{VTKCellType, Tuple{Int64, Int64, Int64}}(VTKCellType(\"VTK_TRIANGLE\", 0x05, 3), (3, 5, 42))\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.MultiblockFile","page":"API Reference","title":"WriteVTK.MultiblockFile","text":"MultiblockFile <: VTKFile\n\nHandler for a multiblock VTK file (.vtm).\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.StructuredVTKDataset","page":"API Reference","title":"WriteVTK.StructuredVTKDataset","text":"StructuredVTKDataset <: AbstractVTKDataset\n\nAbstract type representing a structured VTK dataset.\n\nSubtypes are VTKImageData, VTKRectilinearGrid and VTKStructuredGrid.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.UnstructuredVTKDataset","page":"API Reference","title":"WriteVTK.UnstructuredVTKDataset","text":"UnstructuredVTKDataset <: AbstractVTKDataset\n\nAbstract type representing an unstructured VTK dataset.\n\nSubtypes are VTKPolyData and VTKUnstructuredGrid.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKBlock","page":"API Reference","title":"WriteVTK.VTKBlock","text":"VTKBlock\n\nHandler for a nested block in a multiblock file.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKCellData","page":"API Reference","title":"WriteVTK.VTKCellData","text":"VTKCellData <: AbstractFieldData\n\nRepresents data that is to be attached to grid cells.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKFieldData","page":"API Reference","title":"WriteVTK.VTKFieldData","text":"VTKFieldData <: AbstractFieldData\n\nRepresents data that is not attached to the grid geometry.\n\nThis is typically used for lightweight metadata, such as timestep information or strings.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKFile","page":"API Reference","title":"WriteVTK.VTKFile","text":"VTKFile\n\nAbstract type describing a VTK file that may be written using vtk_save.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKImageData","page":"API Reference","title":"WriteVTK.VTKImageData","text":"VTKImageData <: StructuredVTKDataset\n\nRepresents the VTK image data format (.vti extension).\n\nThis corresponds to rectangular grids with uniform spacing in all directions.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKPointData","page":"API Reference","title":"WriteVTK.VTKPointData","text":"VTKPointData <: AbstractFieldData\n\nRepresents data that is to be attached to grid points.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKPolyData","page":"API Reference","title":"WriteVTK.VTKPolyData","text":"VTKPolyData <: UnstructuredVTKDataset\n\nRepresents the VTK polydata format (.vtp extension).\n\nThese are unstructured datasets that accept a limited set of cells types, defined in the PolyData module.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKPolyhedron","page":"API Reference","title":"WriteVTK.VTKPolyhedron","text":"VTKPolyhedron <: AbstractMeshCell\n\nRepresents a polyhedron cell in an unstructured grid.\n\nUsing VTKPolyhedron should be preferred to using a MeshCell with a cell type VTKCellTypes.VTK_POLYHEDRON, since the latter cannot hold all the necessary information to describe a polyhedron cell.\n\n\n\nVTKPolyhedron(connectivity, faces...)\n\nConstruct polyhedron cell from connectivity vector (see MeshCell for details) and from a list of polyhedron faces.\n\nExample\n\nCreate a polyhedron with 8 points and 6 faces. This can represent a cube if the 8 points are properly positioned.\n\njulia> cell = VTKPolyhedron(\n           1:8,\n           (1, 4, 3, 2),\n           (1, 5, 8, 4),\n           (5, 6, 7, 8),\n           (6, 2, 3, 7),\n           (1, 2, 6, 5),\n           (3, 4, 8, 7),\n       )\nVTKPolyhedron{UnitRange{Int64}, NTuple{6, NTuple{4, Int64}}}(1:8, ((1, 4, 3, 2), (1, 5, 8, 4), (5, 6, 7, 8), (6, 2, 3, 7), (1, 2, 6, 5), (3, 4, 8, 7)))\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKRectilinearGrid","page":"API Reference","title":"WriteVTK.VTKRectilinearGrid","text":"VTKRectilinearGrid <: StructuredVTKDataset\n\nRepresents the VTK rectilinear grid format (.vtr extension).\n\nThis corresponds to rectangular grids with non-uniform spacing.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKStructuredGrid","page":"API Reference","title":"WriteVTK.VTKStructuredGrid","text":"VTKStructuredGrid <: StructuredVTKDataset\n\nRepresents the VTK structured grid format (.vts extension).\n\nThis corresponds to curvilinear grids, the most general kind of structured grid.\n\n\n\n\n\n","category":"type"},{"location":"API/#WriteVTK.VTKUnstructuredGrid","page":"API Reference","title":"WriteVTK.VTKUnstructuredGrid","text":"VTKUnstructuredGrid <: UnstructuredVTKDataset\n\nRepresents the VTK unstructured format (.vtu extension).\n\nThis is the most general kind of unstructured grid, which accepts all cell types defined in the VTKCellTypes module.\n\n\n\n\n\n","category":"type"},{"location":"API/#Base.close-Tuple{WriteVTK.VTKFile}","page":"API Reference","title":"Base.close","text":"close(vtk::VTKFile)\n\nWrite and close VTK file.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.isopen-Tuple{WriteVTK.VTKFile}","page":"API Reference","title":"Base.isopen","text":"isopen(vtk::VTKFile)\n\nCheck if VTK file is still being written.\n\n\n\n\n\n","category":"method"},{"location":"API/#Base.setindex!-Tuple{WriteVTK.DatasetFile, Any, AbstractString, WriteVTK.AbstractFieldData}","page":"API Reference","title":"Base.setindex!","text":"setindex!(vtk::DatasetFile, data, name::AbstractString, [field_type])\n\nAdd a new dataset to VTK file.\n\nThe number of components of the dataset (e.g. for scalar or vector fields) is determined automatically from the input data dimensions.\n\nThe optional argument field_type should be an instance of VTKPointData, VTKCellData or VTKFieldData. It determines whether the data should be associated to grid points, cells or none. If not given, this is guessed from the input data size and the grid dimensions.\n\nExample\n\nAdd \"velocity\" dataset and time scalar to VTK file.\n\nvel = rand(3, 12, 14, 42)  # vector field\ntime = 42.0\n\nvtk = vtk_grid(...)\nvtk[\"velocity\", VTKPointData()] = vel\nvtk[\"time\", VTKFieldData()] = time\n\n# This also works, and will generally give the same result:\nvtk[\"velocity\"] = vel\nvtk[\"time\"] = time\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.add_field_data-Tuple{WriteVTK.DatasetFile, Any, AbstractString, WriteVTK.AbstractFieldData}","page":"API Reference","title":"WriteVTK.add_field_data","text":"add_field_data(vtk::DatasetFile, data,\n               name::AbstractString, loc::AbstractFieldData)\n\nAdd either point or cell data to VTK file.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml","page":"API Reference","title":"WriteVTK.data_to_xml","text":"data_to_xml(\n    vtk::DatasetFile, xParent::XMLElement, data,\n    name::AbstractString, Nc::Union{Int,AbstractFieldData} = 1,\n)\n\nAdd numerical data to VTK XML file.\n\nData is written under the xParent XML node.\n\nNc may be either the number of components, or the type of field data. In the latter case, the number of components will be deduced from the data dimensions and the type of field data.\n\n\n\n\n\n","category":"function"},{"location":"API/#WriteVTK.data_to_xml_appended-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_appended","text":"data_to_xml_appended(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd appended raw binary data to VTK XML file.\n\nData is written to the vtk.buf buffer.\n\nWhen compression is enabled:\n\nthe data array is written in compressed form (obviously);\nthe header, written before the actual numerical data, is an array of HeaderType (UInt32 / UInt64) values:\n[num_blocks, blocksize, last_blocksize, compressed_blocksizes]\nAll sizes are in bytes. The header itself is not compressed, only the data is. For more details, see:\nhttp://public.kitware.com/pipermail/paraview/2005-April/001391.html\nhttp://mathema.tician.de/what-they-dont-tell-you-about-vtk-xml-binary-formats\n\nOtherwise, if compression is disabled, the header is just a single HeaderType value containing the size of the data array in bytes.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml_ascii-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_ascii","text":"data_to_xml_ascii(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd inline data to VTK XML file in ASCII format.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.data_to_xml_inline-Tuple{WriteVTK.DatasetFile, LightXML.XMLElement, Any}","page":"API Reference","title":"WriteVTK.data_to_xml_inline","text":"data_to_xml_inline(vtk::DatasetFile, xDA::XMLElement, data)\n\nAdd inline, base64-encoded data to VTK XML file.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.multiblock_add_block","page":"API Reference","title":"WriteVTK.multiblock_add_block","text":"multiblock_add_block(\n    vtm::Union{MultiblockFile, VTKBlock},\n    vtk::VTKFile,\n    [name = \"\"],\n) -> nothing\n\nAdd a block to a MultiblockFile or a VTKBlock.\n\n\n\nmultiblock_add_block(\n    vtm::Union{MultiblockFile, VTKBlock},\n    [name = \"\"],\n) -> VTKBlock\n\nCreate a sub-block in a MultiblockFile or a VTKBlock.\n\nReturns a new VTKBlock.\n\n\n\n\n\n","category":"function"},{"location":"API/#WriteVTK.paraview_collection-Tuple{Function, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.paraview_collection","text":"paraview_collection(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = paraview_collection(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.paraview_collection_load-Tuple{Function, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.paraview_collection_load","text":"paraview_collection_load(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = paraview_collection_load(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.pvtk_grid-Tuple{AbstractString, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.pvtk_grid","text":"pvtk_grid(args...; part, nparts, ismain = (part == 1), ghost_level = 0, kwargs...)\n\nReturns a handler representing a parallel vtk file, which can be eventually written to file with vtk_save.\n\nPositional and keyword arguments in args and kwargs are passed to vtk_grid verbatim (except file names that are augmented with the corresponding part id).\n\nThe extra keyword arguments only apply to parallel VTK file formats.\n\nMandatory ones are:\n\npart current (1-based) part id,\nnparts total number of parts,\n\nOptional ones are:\n\nismain true if the current part id part is the main (the only one that will write the .pvtk file),\nghost_level ghost level.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.pvtk_grid-Tuple{Function, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.pvtk_grid","text":"pvtk_grid(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = pvtk_grid(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.save_with_appended_data-Tuple{WriteVTK.DatasetFile}","page":"API Reference","title":"WriteVTK.save_with_appended_data","text":"Write VTK XML file containing appended binary data to disk.\n\nIn this case, the XML file is written manually instead of using the save_file function of LightXML, which doesn't allow to write raw binary data.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{AbstractString, Vararg{AbstractRange, N} where N}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename, x::AbstractRange{T}, y::AbstractRange{T}, [z::AbstractRange{T}];\n         kwargs...)\n\nCreate image data (.vti) file.\n\nAlong each direction, the grid is specified in terms of an AbstractRange object.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3, 4:1.:5)  # 3D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"abc\", 1:5, 2:1.:3, range(4, 5; length = 3))  # different kinds of ranges\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"abc\", 1:0.2:5, 2:1.:3)  # 2D dataset\nVTK file 'abc.vti' (ImageData file, open)\n\njulia> vtk = vtk_grid(\"def\",\n                      LinRange(0., 5., 10),\n                      LinRange(0., 2π, 16),\n                      LinRange(1., 10., 12))\nVTK file 'def.vti' (ImageData file, open)\n\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{Function, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = vtk_grid(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Tuple{Union{WriteVTK.MultiblockFile, WriteVTK.VTKBlock}, AbstractString, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(vtm::Union{MultiblockFile, VTKBlock}, [filename], griddata...; kwargs...)\n\nCreate new dataset file that is added to an existent multiblock file. The VTK grid is specified by the elements of griddata.\n\nIf the filename is not given, it is determined automatically from the filename associated to vtm and the number of existent blocks.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_grid-Union{Tuple{T}, Tuple{AbstractString, AbstractVector{T}, AbstractVector{T}, AbstractVector{T}}} where T","page":"API Reference","title":"WriteVTK.vtk_grid","text":"vtk_grid(filename::AbstractString,\n         x::AbstractVector{T}, y::AbstractVector{T}, [z::AbstractVector{T}];\n         kwargs...)\n\nCreate 2D or 3D rectilinear grid (.vtr) file.\n\nCoordinates are specified by separate vectors x, y, z.\n\nExamples\n\njulia> vtk = vtk_grid(\"abc\", [0., 0.2, 0.5], collect(-2.:0.2:3), [1., 2.1, 2.3])\nVTK file 'abc.vtr' (RectilinearGrid file, open)\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_multiblock-Tuple{AbstractString}","page":"API Reference","title":"WriteVTK.vtk_multiblock","text":"vtk_multiblock([f::Function], filename) -> MultiblockFile\n\nInitialise VTK multiblock file, linking multiple VTK dataset files.\n\nReturns a handler for a multiblock file. To recursively save the multiblock file and linked dataset files, call vtk_save on the returned handler.\n\nNote that vtk_save is implicitly called if the optional f argument is passed. This is in particular what happens when using the do-block syntax.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_multiblock-Tuple{Function, Vararg{Any, N} where N}","page":"API Reference","title":"WriteVTK.vtk_multiblock","text":"vtk_multiblock(f::Function, args...; kwargs...)\n\nCreate VTK file and apply f to it. The file is automatically closed by the end of the call.\n\nThis allows to use the do-block syntax for creating VTK files:\n\nsaved_files = vtk_multiblock(args...; kwargs...) do vtk\n    # do stuff with the `vtk` file handler\nend\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_save-Tuple{WriteVTK.MultiblockFile}","page":"API Reference","title":"WriteVTK.vtk_save","text":"vtk_save(vtm::MultiblockFile)\n\nSave and close multiblock file (.vtm). The VTK files included in the multiblock file are also saved.\n\n\n\n\n\n","category":"method"},{"location":"API/#WriteVTK.vtk_write_array-Union{Tuple{S}, Tuple{A}, Tuple{N}, Tuple{M}, Tuple{T}, Tuple{AbstractString, Tuple{Vararg{A, M}}, Tuple{Vararg{S, M}}}} where {T<:Real, M, N, A<:AbstractArray{T, N}, S<:AbstractString}","page":"API Reference","title":"WriteVTK.vtk_write_array","text":"vtk_write_array(filename, arrays, labels)\nvtk_write_array(filename, array; label = \"array\")\n\nWrite Julia arrays to a VTK image data file (.vti).\n\nUseful for general visualisation of arrays. The input can be a 2D or 3D array.\n\nMultiple arrays can be given as a tuple. For instance,\n\nvtk_write_array(filename, (u, v), (\"u\", \"v\"))\n\nIn that case, the arrays must have the same dimensions.\n\n\n\n\n\n","category":"method"},{"location":"API/#VTKCellTypes","page":"API Reference","title":"VTKCellTypes","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Modules = [VTKCellTypes]","category":"page"},{"location":"API/#WriteVTK.VTKCellTypes","page":"API Reference","title":"WriteVTK.VTKCellTypes","text":"VTKCellTypes\n\nModule defining cell types for unstructured datasets.\n\nDefinitions are adapted from the VTK source code.\n\n\n\n\n\n","category":"module"},{"location":"API/#WriteVTK.VTKCellTypes.nodes-Tuple{VTKCellType}","page":"API Reference","title":"WriteVTK.VTKCellTypes.nodes","text":"nodes(c::VTKCellTypes)\n\nReturns the number of nodes (or grid points) required by the cell type.\n\nFor instance, this returns 3 for VTK_TRIANGLE.\n\nFor cell types that can take any number of nodes, such as VTK_POLY_LINE, this returns -1.\n\n\n\n\n\n","category":"method"},{"location":"API/#PolyData","page":"API Reference","title":"PolyData","text":"","category":"section"},{"location":"API/","page":"API Reference","title":"API Reference","text":"Modules = [PolyData]","category":"page"},{"location":"API/#WriteVTK.PolyData","page":"API Reference","title":"WriteVTK.PolyData","text":"PolyData\n\nDefines cell types for polygonal datasets.\n\nThe following singleton types are defined:\n\nPolyData.Verts for vertices,\nPolyData.Lines for lines,\nPolyData.Strips for triangular strips,\nPolyData.Polys for polygons.\n\n\n\n\n\n","category":"module"},{"location":"tools/readvtk/#Reading-VTK-files","page":"Reading VTK files","title":"Reading VTK files","text":"","category":"section"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"The ReadVTK.jl package, mainly written by Michael Schlottke-Lakemper and the Trixi authors, may be used to read VTK files.","category":"page"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"Note that ReadVTK.jl is specifically meant for reading VTK XML files generated by WriteVTK.jl, and may not be able to read VTK files coming from other sources.","category":"page"},{"location":"tools/readvtk/","page":"Reading VTK files","title":"Reading VTK files","text":"See the ReadVTK.jl documentation for details on what can and cannot be done with it.","category":"page"},{"location":"metadata/paraview_collections/#ParaView-collections","page":"ParaView collections","title":"ParaView collections","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"A ParaView collection file (extension .pvd) represents a time series of VTK files. This may be used for visualising simulation results at different time steps, and in particular for creating simulation movies.","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"A pvd file is initialised using paraview_collection:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd = paraview_collection(\"my_pvd_file\")","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"By default this overwrites existent pvd files. To append new datasets to an existent pvd file, set the append option to true:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd = paraview_collection(\"my_pvd_file\"; append = true)","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"VTK files are then added to the pvd file with","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"pvd[time] = vtk","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"Here, time is a real number that represents the current time (or timestep) in the simulation.","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"When all the files are added to the pvd file, it can be saved using:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"vtk_save(pvd)","category":"page"},{"location":"metadata/paraview_collections/#Working-example","page":"ParaView collections","title":"Working example","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"The following is a full working example using the do-block syntax:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"x, y, z = 0:10, 1:6, 2:0.1:3\ntimes = range(0, 10; step = 0.5)\n\nsaved_files = paraview_collection(\"full_simulation\") do pvd\n    for (n, time) ∈ enumerate(times)\n        vtk_grid(\"timestep_$n\", x, y, z) do vtk\n            vtk[\"Pressure\"] = rand(length(x), length(y), length(z))\n            pvd[time] = vtk\n        end\n    end\nend","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"In this example, the saved files are:","category":"page"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"julia> saved_files\n22-element Vector{String}:\n \"full_simulation.pvd\"\n \"timestep_1.vti\"\n \"timestep_2.vti\"\n \"timestep_3.vti\"\n \"timestep_4.vti\"\n \"timestep_5.vti\"\n \"timestep_6.vti\"\n \"timestep_7.vti\"\n ⋮\n \"timestep_15.vti\"\n \"timestep_16.vti\"\n \"timestep_17.vti\"\n \"timestep_18.vti\"\n \"timestep_19.vti\"\n \"timestep_20.vti\"\n \"timestep_21.vti\"","category":"page"},{"location":"metadata/paraview_collections/#Acknowledgements","page":"ParaView collections","title":"Acknowledgements","text":"","category":"section"},{"location":"metadata/paraview_collections/","page":"ParaView collections","title":"ParaView collections","text":"Thanks to Patrick Belliveau for the initial implementation of ParaView collection functionality, and to Sebastian Pech for additional improvements.","category":"page"},{"location":"#WriteVTK.jl","page":"Home","title":"WriteVTK.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package allows to write VTK XML files for visualisation of multidimensional datasets using tools such as ParaView. A wide range of VTK formats is supported, including different kinds of structured and unstructured grids, as well as metadata files for describing time series or multi-block domains.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WriteVTK can be installed using the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ] add WriteVTK","category":"page"},{"location":"#Quick-start","page":"Home","title":"Quick start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The vtk_grid function is the entry point for creating different kinds of VTK files. In the simplest cases, one just passes coordinate information to this function. WriteVTK.jl then determines the VTK format that is more adapted for the provided data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For instance, it is natural in Julia to describe a uniform three-dimensional grid (with regularly-spaced increments) as a set of ranges:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x = 0:0.1:1\ny = 0:0.2:1\nz = -1:0.05:1","category":"page"},{"location":"","page":"Home","title":"Home","text":"This specific way of specifying coordinates is compatible with the image data VTK format, which has the .vti extension. The following creates such a file, with some scalar data attached to each point:","category":"page"},{"location":"","page":"Home","title":"Home","text":"vtk_grid(\"fields\", x, y, z) do vtk\n    vtk[\"temperature\"] = rand(length(x), length(y), length(z))\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will create a fields.vti file with the data. Note that the file extension should not be included in the filename, as it will be attached automatically according to the dataset type.","category":"page"},{"location":"","page":"Home","title":"Home","text":"By changing the coordinate specifications, the above can be naturally generalised to non-uniform grid spacings and to curvilinear and unstructured grids. In each case, the correct kind of VTK file will be generated.","category":"page"},{"location":"#Supported-VTK-formats","page":"Home","title":"Supported VTK formats","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package attempts to implement writers for all VTK XML formats described in the VTK specification. Note that legacy (non-XML) files are not supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Supported dataset formats include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"image data (.vti),\nrectilinear grid (.vtr),\nstructured (or curvilinear) grid (.vts),\nunstructured grid (.vtu),\npolydata (.vtp, a specific type of unstructured grid).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Moreover, the following metadata formats are supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"multiblock files (.vtm),\nParaView collections (.pvd, typically used for time series),\nparallel files (.pvt*, only partial support for now).","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is mainly written and maintained by Juan Ignacio Polanco, with many important contributions by Fredrik Ekre. Moreover, a number of authors have implemented additional functionality, and are acknowledged throughout the documentation.","category":"page"}]
}
